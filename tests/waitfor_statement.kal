describe 'Wait For Statement', ->
  it 'should accept single arguments', (done) ->
    task callbacker (arg1)
      return arg1 + 1
    wait for x from callbacker 5
    x.should.equal 6
    done()
  
  it 'should accept multiple arguments', (done) ->
    task callbacker2 (arg1, arg2, arg3)
      return arg1 + 1, arg2 - 1, arg3 + 2
    wait for x, y, z from callbacker2 5, 6, 7
    x.should.equal 6
    y.should.equal 5
    z.should.equal 9
    done()
  
  it 'should work inside of if statements', (done) ->
    task callbacker3(arg1)
      return arg1 * 2
    x = 2
    if x is 2
      wait for y from callbacker3 7
      n = 2
    else
      wait for z from callbacker3 8
    y.should.equal 14
    n.should.equal 2
    (z doesnt exist).should.be.true
    done()
  
  it 'should work inside of else if statements', (done) ->
    task callbacker3(arg1)
      return arg1 * 2
    x = 2
    if x is 5
      wait for y from callbacker3 7
      n = 2
    else if x is 2
      n = 4
      wait for z from callbacker3 8
    else
      n = 5
    z.should.equal 16
    n.should.equal 4
    (y doesnt exist).should.be.true
    done()
  
  it 'should work inside of nested if statements (1)', (done) ->
    task callbacker3(arg1)
      return arg1 * 2
    x = 5
    if x is 5 #true
      wait for y from callbacker3 7
      if y is 3
        y = 10
        n = 0
      else #true, it's 14
        n = 0
        wait for y from callbacker3 y
        n = 0
        y += 1 #28+1=29
      n = 2
    else if x is 2
      n = 4
      wait for z from callbacker3 8
    else
      n = 5
      if yes
        wait for p from callbacker3 1
    y.should.equal 29
    n.should.equal 2
    (p doesnt exist).should.be.true
    (z doesnt exist).should.be.true
    done()
    
  it 'should work inside of nested if statements (2)', (done) ->
    task callbacker4(arg1)
      return arg1 * 2
    x = 1
    if x is 5
      wait for y from callbacker4 7
      if y is 3
        y = 10
        n = 0
      else #true, it's 14
        n = 0
        wait for y from callbacker4 y
        n = 0
        y += 1 #28+1=29
      n = 2
    else if x is 2
      n = 4
      wait for z from callbacker4 8
    else #true
      n = 5
      if yes
        wait for p from callbacker4 1
    p.should.equal 2
    n.should.equal 5
    (t doesnt exist).should.be.true
    (z doesnt exist).should.be.true
    done()
    
  it 'should work inside of nested if statements (3)', (done) ->
    task callbacker5(arg1)
      return arg1 * 3
    x = 2
    y = 3
    if x is 5
      wait for z from callbacker5 7
      if y is 3
        z = 10
        n = 0
      else
        n = 1
        wait for y from callbacker5 y
        n = 0
        y += 1
      n = 2
    else if x is 2 #true
      n = 4
      if y isnt 3
        z = 10
      else #true
        if x is 2 # true
          wait for z from callbacker5 8
          z += 1
      if z is 25 # true
        wait for z from callbacker5 z
    else #true
      n = 5
      if yes
        wait for p from callbacker4 1
    z.should.equal 75
    n.should.equal 4
    done()
  
  it 'should work inside of for parallel in loops', (done) ->
    task callbacker3(arg1)
      return arg1 * 2
    output = []
    for parallel i in [1,2,3,4]
      wait for j from callbacker3 i
      output.push j
    expected = [2,4,6,8]
      
    for o in output
      (o in expected).should.be.true
    done()
    
  it 'should work inside of for serial in loops', (done) ->
    task callbacker3(arg1)
      return arg1 * 2
    output = []
    for series i in [1,2,3,4]
      wait for j from callbacker3 i
      output.push j
    expected = [2,4,6,8]

    output.should.eql expected
    done()
  
  it 'should handle nested loops', (done) ->
    task shrinker(i)
      return i - 9
    grids = [[[1,2,3],[4,5,6],[7,8,9]],[[10,11,12],[13,14,15],[16,17,18]]]
    sum = 0
    for parallel grid in grids
      grid.length.should.equal 3
      for series row in grid
        row.length.should.equal 3
        for parallel column in row
          if column > 9
            wait for icolumn from shrinker(column)
          else
            icolumn = column
          sum += icolumn
    sum.should.equal 90
    done()
          
  #TODO: test error handling in loops
  #TODO: test nested loops/ifs
  it 'should work inside of while loops', (done) ->
    task callbacker3(arg1)
      return arg1 * 2
    output = []
    i = 1
    while i <= 4
      wait for j from callbacker3 i
      output.push j
      i += 1
    expected = [2,4,6,8]

    output.should.eql expected
    done()
    
  it 'should throw when called back with an error from a task', (done) ->
    task callbacker10(arg1)
      fail with "error!!!"
    error_happened = no
    try
      wait for x from callbacker10 5
    catch e
      e.should.equal "error!!!"
      error_happened = yes
    error_happened.should.be.true
    done()
  
  it 'should preserve try/catch blocks within callbacks', (done) ->
    task callbacker11(arg1)
      return arg1
    caught = []
    try
      wait for x from callbacker11 5
      fail with 'test1'
    catch e
      e.should.equal 'test1'
      caught.push 1
    try
      try
        wait for x from callbacker11 5
        fail with 'test2'
      catch e
        e.should.equal 'test2'
        caught.push 2
      fail with 'test3'  
    catch e
      e.should.equal 'test3'
      caught.push 3
    caught.should.eql [1,2,3]
    done()
  
  it 'should work if the called task takes no arguments', (done) ->
    task callbacker4()
      return 5
    wait for x from callbacker4()
    x.should.equal 5
    done()
