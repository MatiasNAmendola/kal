class ParseFailed inherits from Error
  method initialize(message)
    this.message = message
    ParseFailed.__super__.constructor.apply me, arguments
  

class SyntaxError inherits from ParseFailed
  method initialize()
    SyntaxError.__super__.constructor.apply me, arguments
  

exports.SyntaxError = SyntaxError

class ASTBase
  method initialize(ts)
    me.locked = no
    me.ts = ts
    me.line = ts.line
    me.parse()
    
  #optionally match one of the classes or tokens in the list
  method opt()
    rv = null
    start_index = me.ts.index
    for cls in arguments
      if typeof(cls) is 'string'
        if me.ts.type is cls
          rv = me.ts.current
          me.ts.next()
          return rv
      else
        try
          rv = new cls me.ts
          return rv
        catch e
          me.ts.goto_token start_index
          throw(e) when e instanceof SyntaxError
    return null
  
  #require match to one of the classes or tokens in the list
  method req() 
    rv = me.opt.apply this, arguments
    return rv when rv exists
    list = []
    for cls in arguments
      list.push cls.name or cls
    if list.length is 1
      message = "Expected #{list[0]}"
    else
      message = "Expected one of #{list.join(', ')}"
    me.error "#{message}"
  
  method opt_val() #require token value
    if me.ts.value in arguments
      rv = me.ts.current
      me.ts.next()
      return rv
    else
      return null
      
  method req_val()
    rv = me.opt_val.apply this, arguments
    return rv when rv exists
    arglist = []
    for v in arguments
      arglist.push v
    me.error "Expected #{arglist.join(' or ')}"
  
  method req_multi() #require at least one
    rv = me.opt_multi.apply this, arguments
    return rv when rv.length > 0
    
    list = []
    for cls in arguments
      list.push cls.name or cls
    me.error "Expected one of #{list.join(', ')}"
    
    
  method opt_multi() #optionally have multiple
    cls = me.opt.apply this, arguments
    return [] when cls doesnt exist
    rv = [cls]
    while cls exists
      cls = me.opt.apply this, arguments
      rv.push(cls) when cls exists
    return rv
  
  method parse()
    me.error 'Parser Not Implemented: ' + me.constructor.name
    
  method js()
    me.error 'Javascript Generator Not Implemented: ' + me.constructor.name
    
  method error(msg)
    full_msg = msg + ' on line ' + me.line
    if me.locked
      throw(new SyntaxError full_msg)
    else
      throw(new ParseFailed full_msg)
    
  method lock()
    me.locked = yes

exports.ASTBase = ASTBase