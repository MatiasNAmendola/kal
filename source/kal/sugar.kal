grammar = require '../source/coffee/grammar'

KEYWORDS = grammar.KEYWORDS
NOPAREN_WORDS = ['is','otherwise','except','else','doesnt','exist','exists','isnt','inherits','from','and','or','xor','in','when','instanceof','of']

function translate_sugar(tokens)
  out_tokens = coffee_style_functions noparen_function_calls multiline_statements clean tokens
  return out_tokens
exports.translate_sugar = translate_sugar

function clean(tokens)
  # close out with a newline in case the user did not, remove whitespace
  out_tokens = []
  for token in tokens
    out_tokens.push(token) when token.type isnt 'WHITESPACE'
  t = {text:'\n', line:last_token?.line, value:'', type:'NEWLINE'}
  out_tokens.push t
  return out_tokens

function multiline_statements(tokens)
  # allow multi-line statements with line breaks after commas, colons, and equal signs
  out_tokens = []
  last_token = null
  continue_line = no
  reduce_dedent = 0
  
  for token in tokens
    skip_token = no
    if token.type is 'NEWLINE' and (last_token?.value in [',','=',':'])
      continue_line = yes
      skip_token = yes
    else if continue_line
      if token.type is 'INDENT'
        skip_token = yes
        reduce_dedent += 1
      else if token.type is 'NEWLINE'
        skip_token = yes
      else if token.type is 'DEDENT'
        if reduce_dedent > 0
          reduce_dedent -= 1
          skip_token = yes
          if reduce_dedent is 0
            t =  {text:'\n', line:token.line, value:'',type:'NEWLINE'}
            out_tokens.push t
        else
          out_tokens.push last_token #add back in the newline
    out_tokens.push(token) when not skip_token
    last_token = token
  return out_tokens
  
function noparen_function_calls(tokens)
  # allow function calls without parentheses
  out_tokens = []
  close_paren_count = 0
  last_token = null
  closes_on = []

  i = 0
  while i < tokens.length
    token = tokens[i]
    last_is_identifier = last_token?.type is 'IDENTIFIER' and not (last_token.value in KEYWORDS)
    current_is_identifier = token.type in ['IDENTIFIER','NUMBER','STRING']
    current_not_excluded = not (token.value in NOPAREN_WORDS)
    if last_is_identifier and current_is_identifier and current_not_excluded
      closes_on.push 'NEWLINE'
      out_tokens.push {text:'(', line:token.line, value:'(', type:'LITERAL'}
    else if (last_token?.value is '-' and token.value is '>') or token.value is 'function'
      closes_on[closes_on.length - 1] = 'DEDENT'

    if token.type is closes_on[closes_on.length - 1]
      closes_on.pop()
      out_tokens.push token if token.type is 'DEDENT'
      out_tokens.push {text:')', line:token.line, value:')', type:'LITERAL'}
      out_tokens.push token if token.type isnt 'DEDENT'
    else
      out_tokens.push token
    last_token = token
    i += 1
  return out_tokens

function coffee_style_functions(tokens)
  #allow function definitions with the -> operator
  out_tokens = []
  last_token = null

  i = 0
  while i < tokens.length
    token = tokens[i]
    if last_token?.value is '-' and token?.value is '>'
      out_tokens.pop() # remove the dash
      new_tokens = []
      t = out_tokens.pop()
      if t?.value is ')'
        while t?.value isnt '('
          new_tokens.unshift t
          t = out_tokens.pop()
        new_tokens.unshift t
      else
        out_tokens.push t
        new_tokens.push {text:'(', line:token.line, value:'(', type:'LITERAL'}
        new_tokens.push {text:')', line:token.line, value:')', type:'LITERAL'}
      f_token = {text:'function', line:token.line, value:'function', type:'IDENTIFIER'}
      new_tokens.unshift f_token
      out_tokens = out_tokens.concat new_tokens
    else
      # push the current token unchanged
      out_tokens.push token
    last_token = token
    i += 1
  return out_tokens

