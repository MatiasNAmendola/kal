KEYWORD_TRANSLATE = {'yes':'true','on':'true','no':'false','off':'false','is':'===','isnt':'!==','==':'===','!=':'!==','and':'&&','but':'&&','or':'||','xor':'^','^':'pow','not':'!','new':'new ','me':'this','this':'this','null':'null','nothing':'null','none':'null','break':'break','throw':'throw','raise':'throw','instanceof':'instanceof','of':'in','EndOfList':'undefined','fail':'throw'}

load = function load (grammar)
  apply_generator_to_grammar.apply grammar
exports.load = load

function apply_generator_to_grammar()
  i = ''
  function indent()
    i += '  '
  
  function dedent()
    i = i.slice(0,0-2)
  
  scopes = []
  scope = {}
  
  callback_counter = 0
  
  function create_callback()
    callback_counter += 1
    return "$kcb#{callback_counter}"
  
  class_defs = []
  class_def = {}
  
  function push_class()
    class_defs.push class_def
    class_def = {name: '', code: '',args: [],has_constructor: no}
    
  function pop_class()
    class_def = class_defs.pop()
    return class_def
  
  use_snippets = {}
  
  function push_scope()
    scopes.push scope
    new_scope = {}
    for k of scope
      v = scope[k]
      if v is 'no closures'
        v = v #do nothing
      else if v is 'closures ok' or v is 'argument' or v is 'function'
        new_scope[k] = 'closure'
      else if v is 'closure'
        new_scope[k] = 'closure'
    scope = new_scope
    
  function pop_scope(code, wrap)
    rv = i
    var_names = []
    for var_name of scope
      if not (scope[var_name] in ['closure', 'argument', 'function', 'class definition'])
        var_names.push(var_name)
    if wrap
      rv += '(function () {\n'
      indent()
      code = i + code.replace(/\n/g, '\n  ')
    if var_names.length > 0
      rv += '  var ' + var_names.join(', ') + ';\n'
    rv += code
    if wrap
      dedent()
      rv += "\n#{i}})()\n"
    if scopes isnt []
      scope = scopes.pop()
    return rv
  
  function check_existence_wrapper(code, undefined_unary, invert)
    if undefined_unary
      rv = "(typeof #{code} === 'undefined' || #{code} === null)" when invert otherwise "(typeof #{code} !== 'undefined' && #{code} !== null)"
    else
      rv = "#{code} == null" when invert otherwise "#{code} != null"
    return rv
  
  self = this
  
  me.ASTBase.prototype.js_next_callback = ->
    if me.next_callback exists
      return me.next_callback
    else if me.ast_parent exists
      return me.ast_parent.js_next_callback()
    else
      return null
  me.ASTBase.prototype.js_enable_callbacks = ->
    me.ast_parent.js_enable_callbacks() when me.ast_parent exists
    
  me.File.prototype.js = (options) ->
    i = ''
    scopes = []
    scope = {}
    callback_counter = 0
    class_defs = []
    class_def = {name: '',code: '',args: [],has_constructor: no}
    use_snippets = {}
    code = []
    for statement in me.statements
      if not (statement.statement instanceof self.BlankStatement)
        code.push(statement.js())
    code = code.join '\n'
    snip = []
    for key of use_snippets
      snip.push use_snippets[key]
    snip = snip.join('\n')
    rv = [snip, code].join '\n'
    for comment in me.ts.comments # reset the AST modifications in case something else wants to use it
      comment.written = null
    return pop_scope(rv, not options.bare)
    
  me.Statement.prototype.js = ->
    rv = ''
    pf = ''
    for comment in me.ts.comments
      if comment.line < me.line + 1 and not comment.written
        comment.written = yes
        if comment.post_fix
          pf += '\n' when comment.multiline
          pf += ' ' when not comment.multiline
          pf += '/*' + comment.value + '*/'
        else
          rv += i + '/*' + comment.value + '*/\n'
    rv += i + me.statement.js()
    if pf isnt ''
      if rv.match /\n/
        rv = rv.replace /\n/, pf + '\n'
      else
        rv += pf
    return rv
    
  me.ThrowStatement.prototype.js = ->  
    rv = "throw #{this.expr.js()};"
    rv = me.conditional.js(rv, no) if me.conditional?
    return rv
    
  me.ReturnStatement.prototype.js = ->
    next_cb = me.js_next_callback()
    exprs_js = [expr.js() for expr in me.exprs]
    arg_list = exprs_js.join(', ')
    if next_cb exists
      rv = "var $krv = [null,#{arg_list}]; try {$knext.apply(this, $krv);} catch ($kerr) {}; return;"
      rv = me.conditional.js(rv, no) when me.conditional exists
      return rv
    else
      rv = "return"
      if me.exprs.length is 1
        rv += " " + arg_list
      else if me.exprs.length > 1
        rv += "[#{arg_list}]"
      rv += ";"
      rv = me.conditional.js(rv, no) when me.conditional exists
      return rv
      
  me.ExpressionStatement.prototype.js = ->
    rv = me.expr.js()
    if rv is ""
      return ""
    else
      return rv + ";"
    
  me.Expression.prototype.js = (oop_reverse) ->
    rv = ''
    if oop_reverse
      left_code = ''
    else
      left_code = me.left.js()
    if not me.op?
      rv += left_code
    else
      opjs = me.op.js()
      if opjs is 'in' and me.op.op.value isnt 'of'
        unless use_snippets['in']?
          use_snippets['in'] = snippets['in']
          for subscope in scopes
            subscope['$kindexof'] = 'closure'
          scope['$kindexof'] = 'closure'
        rv += "($kindexof.call(#{this.right.left.js()}, #{left_code}) >= 0) #{this.right.js(true)}"
      else if opjs is 'nor'
        rv += "!(#{left_code} || #{this.right.js()})"
      else if opjs is 'pow'
        rv += "Math.pow(#{left_code}, #{this.right.left.js()}) #{this.right.js(true)}"
      else
        rv += "#{left_code} #{opjs} #{this.right.js()}"
    if me.op?.invert
      rv = "!(#{rv})"
    rv = me.conditional.js(rv, yes) if me.conditional exists
    return rv
    
    
  me.UnaryExpression.prototype.js = ->
    rv = ''
    if me.base.type is 'IDENTIFIER'
      base_val = me.base.value
      kw_translate = KEYWORD_TRANSLATE[base_val]
      rv += kw_translate or base_val
      if kw_translate doesnt exist
        scope[base_val] = 'closures ok' unless scope[base_val] exists or (not me.is_lvalue()) or me.accessors.length > 0
    else
      rv += me.base.js()
    
    # an undefined unary is a simple variable access to an undeclared variable
    # it requres we check if the variable exists before checking if it is null/undefined
    undefined_unary = (me.base.type is 'IDENTIFIER' and scope[base_val] doesnt exist and kw_translate doesnt exist)
    existence_qualifiers = []
    
    last_accessor = me.accessors[me.accessors.length-1]
    for accessor in me.accessors
      existence_qualifiers.push accessor.js_existence rv, undefined_unary, last_accessor.invert
      rv += accessor.js()
      undefined_unary = no # only possible for the first accessor
    
    existence_check = []
    for eq in existence_qualifiers
      if eq isnt ""
        existence_check.push eq
    existence_check = existence_check.join(' && ')
    if existence_check isnt ""
      if last_accessor instanceof self.ExisentialCheck
        rv = "(#{existence_check})"
      else
        closeout = "void 0"
        rv = "((#{existence_check}) ? #{rv} : #{closeout})"
      
    if me.preop?.value is 'new'
      rv = "#{KEYWORD_TRANSLATE[this.preop.value]} #{rv}"
    else if me.preop?.value is 'not'
      rv = "#{KEYWORD_TRANSLATE[this.preop.value]}(#{rv})"
    else if me.preop?.value is '-'
      rv = "-#{rv}"
    return rv
    
  me.WhenExpression.prototype.js = (true_block_js, must_return_value) ->
    conditional_js = me.condition.js()
    if me.specifier.value is 'unless' or me.specifier.value is 'except'
      conditional_js = "!(#{conditional_js})" 
    if me.false_expr exists
      return "(#{conditional_js}) ? #{true_block_js} : #{this.false_expr.js()}"
    else
      if must_return_value
        return "(#{conditional_js}) ? #{true_block_js} : void 0"
      else
        indented_js = '  ' + true_block_js.replace(/\n/g, '\n  ')
        return "if (#{conditional_js}) {\n#{indented_js}\n#{i}}"
    return rv
  
  me.ExisentialCheck.prototype.js = ->
    return ""
    
  me.ExisentialCheck.prototype.js_existence = (accessor, undefined_unary, invert) ->
    return check_existence_wrapper(accessor, undefined_unary, invert)
  
  me.PropertyAccess.prototype.js = ->
    if me.expr.type is 'IDENTIFIER'
      rv = me.expr.value
    else
      rv = me.expr.js()
    rv = ".#{rv}"
    return rv
  me.PropertyAccess.prototype.js_existence = (accessor, undefined_unary, invert) ->
    if me.exisential
      return check_existence_wrapper(accessor, undefined_unary, invert)
    else
      return ''
  
  me.AssignmentStatement.prototype.js = ->
    op = me.assignOp.value
    if op isnt '='
      op += '='
    rv = "#{this.lvalue.js()} #{op} #{this.rvalue.js()};"
    rv = me.conditional.js(rv, no) if me.conditional exists
    return rv
    
  me.NumberConstant.prototype.js = ->
    return me.token.text
  
  me.StringConstant.prototype.js = ->
    rv = me.token.value
    return rv
  
  me.RegexConstant.prototype.js = ->
    return me.token.text
  
  me.BinOp.prototype.js = ->
    return KEYWORD_TRANSLATE[me.op.value] or me.op.value
  
  me.IfStatement.prototype.js = ->
    conditional_js = me.conditional.js()
    if me.condition.value is 'unless' or me.condition.value is 'except'
      conditional_js = "!(#{conditional_js})"
    
    rv = "if (#{conditional_js}) {\n#{me.true_block.js()}\n#{i}}"
    rv += me.else_block.js() when me.else_block exists
    
    next_cb = me.js_next_callback()
    if next_cb exists and not me.is_else_if
      rv += "\n#{i}return #{next_cb}();"
      rv += "\n#{i}function #{next_cb}() {"
      me.ast_parent.ast_parent.callback_count += 1
      indent()
      rv += "#{i}try {"
    return rv
  
  me.IfStatement.prototype.js_enable_callbacks = ->
    if me.next_callback doesnt exist but not me.is_else_if
      me.next_callback = create_callback()
    me.ast_parent.js_enable_callbacks()
      
  me.ElseStatement.prototype.js = ->
    if me.false_block instanceof self.Statement and (me.false_block.statement instanceof self.IfStatement)
      me.false_block.statement.is_else_if = yes
      return " else #{this.false_block.statement.js()}"
    else
      return " else {\n#{this.false_block.js()}\n#{i}}"
  
  me.BlankStatement.prototype.js = ->
    return ''
    
  for_depth = 1
  me.ForStatement.prototype.js = ->
    iterator   = "ki$#{for_depth}"
    terminator = "kobj$#{for_depth}"
    scope[iterator] = 'no closures'
    scope[terminator] = 'no closures'
    if me.type.value is 'in'
      rv = "#{terminator} = #{this.iterable.js()};\n#{i}for (#{iterator} = 0; #{iterator} < #{terminator}.length; #{iterator}++) {\n"
    else
      rv = "#{terminator} = #{this.iterable.js()};\nfor (#{this.iterant.js()} in #{terminator}) {\n"
    indent()
    for_depth += 1
    if me.type.value is 'in'
      rv += "#{i}#{this.iterant.js()} = #{terminator}[#{iterator}];\n"
    rv += me.loop_block.js()
    for_depth -= 1
    dedent()
    rv += "\n#{i}}"
    return rv
    
  me.WhileStatement.prototype.js = ->
    rv = "while (#{this.expr.js()}) {\n"
    indent()
    rv += me.block.js()
    dedent()
    rv += "\n#{i}}"
    return rv
    
  me.Block.prototype.js = ->
    me.callback_count = 0
    indent()
    rv = []
    for statement in me.statements
      rv.push statement.js()
    rv = rv.join '\n'
    dedent()
    next_cb = me.js_next_callback() or '$knext'
    while me.callback_count > 0
      dedent()
      rv += "#{i}} catch ($kerr) {if ($knext) {return $knext($kerr);} else {throw $kerr;}}\n"
      if next_cb is '$knext'
        rv += 'return $knext ? $knext() : void 0;'
      else
        rv += "return #{next_cb}();"
      rv += "#{i}}\n"
      me.callback_count -= 1
    return rv
  
  me.ParenExpression.prototype.js = ->
    return "(#{this.expr.js()})"
    
  me.IndexExpression.prototype.js = ->
    return "[#{this.expr.js()}]"
  me.IndexExpression.prototype.js_existence = (accessor, undefined_unary, invert) ->
    if me.exisential
      return check_existence_wrapper(accessor, undefined_unary, invert)
    else
      return ''
  
  me.ListExpression.prototype.js = ->
    if me.comprehension doesnt exist
      rv = []
      for item in me.items
        rv.push item.js()
      rv = rv.join(', ')
      return "[#{rv}]"
    else
      return me.comprehension.js()
  
  me.ListComprehension.prototype.js = ->
    use_snippets['array list comprehension'] = snippets['array list comprehension']
    scope[me.iterant.value] = 'closures ok'
    rv = "$kcomprl(#{me.iterable.js()},function($ki){#{me.iterant.value} = $ki;return #{me.iter_expr.js()};})"
    return rv
  
  me.ObjectComprehension.prototype.js = ->
    use_snippets['object list comprehension'] = snippets['object list comprehension']
    rv = ""
    if me.property_iterant exists
      scope[me.property_iterant.value] = 'closures ok'
      rv += "#{me.property_iterant.value} = $kp;"
    if me.value_iterant exists
      scope[me.value_iterant.value] = 'closures ok'
      rv += "#{me.value_iterant.value} = $kv;"
    rv = "$kcompro(#{me.iterable.js()},function($kp,$kv){#{rv};return #{me.iter_expr.js()};})"
    return rv
  
  me.MapItem.prototype.js = ->
    return "#{this.key.js()}: #{this.val.js()}"
    
  me.MapExpression.prototype.js = ->
    rv = []
    for item in me.items
      rv.push item.js()
    rv = rv.join(', ')
    return "{ #{rv} }"
    
  me.FunctionExpression.prototype.js = ->
    me.args = []
    me.js_enable_callbacks() if me.specifier.value is 'task'
    if class_defs.length > 0 and me.name exists #is a member function/method
      if me.specifier.value is 'method' and me.name.value is 'initialize'
        class_def.code += me.js_constructor()
        return ""
      else
        return me.js_class_member()
    else
      return me.js_bare_function()
    
  me.FunctionExpression.prototype.js_next_callback = ->
    return me.next_callback or null #close out scope
  me.FunctionExpression.prototype.js_enable_callbacks = ->
    me.callback_arg = '$knext'
    me.next_callback = '$knext'
    
  me.FunctionExpression.prototype.js_bare_function   = ->
    rv = "function "
    if me.name exists
      rv += me.name.value
    for argument in me.arguments
      me.args.push argument.name.value
    return rv + me.js_body()
    
  me.FunctionExpression.prototype.js_class_member   = ->
    if me.specifier.value is 'method'
      rv = "#{class_def.name}.prototype.#{this.name.value} = function"
    else
      rv = "#{class_def.name}.#{this.name.value} = function"
    for argument in me.arguments
      me.args.push argument.name.value
    return rv + me.js_body()
    
  me.FunctionExpression.prototype.js_constructor = ->
    class_def.has_constructor = yes
    rv = "function #{class_def.name}"
    class_def.args = []
    for argument in me.arguments
      class_def.args.push argument.name.value
    me.args = class_def.args
    rv += me.js_body class_def.args
    class_def.args.push me.callback_arg when me.callback_arg exists
    return rv
    
  me.FunctionExpression.prototype.js_body = ->
    rv = ""
    push_scope()
    for arg_name in me.args
      scope[arg_name] = 'argument'
    block_code = me.block.js(yes)
    if me.callback_arg exists
      me.args.push me.callback_arg
      block_code = "#{i}try {\n" + block_code
    rv += pop_scope(block_code, no)
    if me.callback_arg exists
      rv += "\n#{i}} catch ($kerr) {if ($knext) {return $knext($kerr);} else {throw $kerr;}}"
      rv += "\n#{i}return $knext ? $knext() : void 0;"
    rv += "\n#{i}}"
    rv = " (#{me.args.join(', ')}) {\n" + rv
    return rv
    
  me.FunctionCall.prototype.js = (as_list) ->
    rv = []
    for argument in me.arguments
      rv.push argument.js()
    rv.push me.callback_name if me.callback_name exists
    rv = rv.join ', '
    if as_list
      return "[#{rv}]"
    else
      return "(#{rv})"
    
  me.FunctionCall.prototype.js_existence = (accessor, undefined_unary, invert) ->
    if me.exisential
      return check_existence_wrapper(accessor, undefined_unary, invert)
    else
      return ''
    
  me.FunctionCallArgument.prototype.js = ->
    return me.val.js()
    
  me.ClassDefinition.prototype.js = ->
    push_scope()
    push_class()
    class_def.name = me.name.value
    class_def.parent = me.parent?.value
    block_code = me.block.js()
    block_code = pop_scope block_code, no
    rv = class_def.code
    unless class_def.has_constructor
      rv += "function #{class_def.name} () {"
      if me.parent?
        rv += "\n#{i}  return #{this.parent.value}.prototype.constructor.apply(this,arguments);\n"
      rv += "}"
    if me.parent?
      rv += "#{i}__extends(#{this.name.value},#{this.parent.value});\n"
      use_snippets['inherits'] = snippets['inherits']
    rv += block_code
    pop_class()
    return rv
  
  me.TryCatch.prototype.js = ->
    rv = "try {\n"
    indent()
    rv += me.try_block.js()
    dedent()
    rv += "#{i}}"
    if me.catch_block exists
      rv += " catch (#{this.identifier.value}) {\n"
      indent()
      rv += me.catch_block.js()
      rv += "}"
    else
      rv += "catch (k$e) {}"
    return rv
    
  me.SuperStatement.prototype.js = ->
    return "" when class_def.parent doesnt exist
    rv = "#{class_def.parent}.prototype.constructor.apply(this,"
    if me.accessor exists
      rv += me.accessor.js(yes)
    else
      rv += "arguments"
    rv += ");"
    return rv
    
  me.WaitForStatement.prototype.js = ->
    me.js_enable_callbacks()
    me.callback_name = create_callback()
    me.rvalue.callback_args = me.lvalue
    me.rvalue.accessors[me.rvalue.accessors.length - 1].callback_name = me.callback_name
    rv = "return #{me.rvalue.js()};\n"
    rv_block = ""
    arg_i = 1
    for argument in me.lvalue.arguments
      rv_block += "#{i}  #{argument.base.value} = arguments[#{arg_i}];\n"
      scope[argument.base.value] = 'closures ok' unless scope[argument.base.value] exists
      arg_i += 1
    
    rv_block += me.block.js()
    rv = me.conditional.js(rv, no) if me.conditional exists #TODO support this for wait fors
    rv += "#{i}function #{me.callback_name} () {\n"
    me.ast_parent.callback_count += 1
    indent()
    rv += "#{i}try {if (arguments[0]) {throw arguments[0];}\n"
    rv += rv_block
    next_cb = me.js_next_callback() or '$knext'
    if next_cb is '$knext'
      caller = '$knext ? $knext() : void 0'
    else
      caller = "#{next_cb}()"
    rv += "#{i}return #{caller}; } catch ($kerr) {if ($knext) {return $knext($kerr);} else {throw $kerr;}}\n"
    dedent()
    rv += "#{i}}\n"
    return rv
    
  snippets = {'in': 'var $kindexof = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };', 'inherits': 'var __hasProp = {}.hasOwnProperty, __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }', 'array list comprehension':'var $kcomprl = function (iterable,func) {var o = []; if (iterable instanceof Array) {for (var i=0;i<iterable.length;i++) {o.push(func(iterable[i]));}} else if (typeof(iterable.next) == "function") {var i; while ((i = iterable.next()) != null) {o.push(func(i));}} else {throw "Object is not iterable";}return o;};', 'object list comprehension':'var $kcompro = function (obj,func) {var o = []; for (var k in obj) {o.push(func(k,obj[k]));}return o;}'}
  