{"name":"Kal","tagline":"A powerful, easy-to-use, and easy-to-read programming language for the future","body":"# Kal\r\n\r\nKal is a highly readable, easy-to-use language that compiles to JavaScript. It's designed to be asynchronous and can run both on [node.js](http://nodejs.org/) and in the browser. Kal makes asynchronous programming easy and clean by allowing functions to [pause and wait for I/O](#asynchronous-wait-for), replacing an awkward callback syntax with a clean, simple syntax.\r\n\r\nKal is also _expressive_ and offers many useful synonyms and constructs to make code readable in almost plain English.\r\n\r\nKal is designed with a unique philosophy:\r\n\r\n 1. Eliminate the yucky parts of JavaScript, but keep the good stuff including the compatibility, and the great server and client runtime support.\r\n 2. Make code as readable as possible and make writing code straightforward. Eliminate the urge (and the need) to be terse and complicated.\r\n * Provide an alternative to callbacks (which look weird) and promises (which are weird) while providing excellent, easy-to-use asynchronous support.\r\n\r\nCheck out the [examples](./examples) for some sample use cases.\r\n\r\n## Asynchronous Wait\r\n\r\n`wait for` allows a function to pause asynchronously, then resume when a task is complete. For example, the following JavaScript:\r\n```javascript\r\nvar getUserFriends(userName, next) {\r\n    db.users.findOne({name:userName}, function (err, user) {\r\n        if (err != null) return next(err);\r\n        db.friends.find({userId:user.id}, function (err, friends) {\r\n            if (err != null) return next(err);\r\n            return next(null, friends);\r\n        });\r\n    });\r\n}\r\n```\r\n\r\nwould be equivalent to this in Kal:\r\n\r\n```kal\r\n    task getUserFriends = function (userName)\r\n      wait for user from db.users.findOne {name:userName}\r\n      wait for friends from db.friends.find {userId:user.id}\r\n      return friends\r\n```\r\n\r\nThis includes error handling via callbacks. Consider a more complicated example:\r\n\r\n```javascript\r\nasync = require('async');\r\n\r\nvar getUserFriends = function (userName, next) {\r\n    db.users.findOne({name:userName}, function (err, user) {\r\n        if (err != null) return next(err);\r\n        getFriendsById(userId, function (err, friends) {\r\n            if (err != null) return next(err);\r\n            if (user.type == 'power user') {\r\n                async.map(friends, getFriendsById, function (err, friendsOfFriends) {\r\n                    for (var i = 0; i < friendsOfFriends.length; i++) {\r\n                        for (var j = 0; j < friendsOfFriends[i].length; j++) {\r\n                            if (friends.indexOf(friendsOfFriends[i][j]) != -1) {\r\n                                friends.push(friendsOfFriends[i][j]);\r\n                            }\r\n                        }\r\n                    }\r\n                    return next(null, friends);\r\n                });\r\n            } else {\r\n                return next(null, friends);\r\n            }\r\n        });\r\n    });\r\n}\r\nvar getFriendsById = function (userId, next) {\r\n    db.friends.find({userId:userId}, function (err, friends) {\r\n        if (err != null) return next(err);\r\n        return next(null, friends);\r\n    });\r\n}\r\n```\r\n\r\nEven using [async](https://github.com/caolan/async), it's lot. Here's the equivalent Kal:\r\n\r\n```kal\r\ntask getUserFriends(userName)\r\n  wait for user from db.users.findOne {name:userName}\r\n  wait for friends from db.friends.find {userId:user.id}\r\n  if user.type is 'power user'\r\n    for parallel friend in friends\r\n      wait for friendsOfFriend from db.friends.find friend\r\n      for newFriend in friendsOfFriend\r\n        friends.push newFriend unless newFriend in friends\r\n  return friends\r\n```\r\n\r\nThere are no additional libraries required and everything's a lot more ... vertical. Notice that the `wait for` statement works in loops, `if` statements, `try`/`catch` blocks, and all nested permutations. It's completely JavaScript compatible - `getUserFriends` would be called the same way and call back with the same results.\r\n\r\n## Installation Using npm\r\n\r\nThis is the preferred method for installing Kal. Make sure you have installed [node.js](http://nodejs.org/). Kal works with versions 0.6, 0.8, and 0.10. It might work with other versions as well. Install the latest \"stable\" release of Kal using npm:\r\n\r\n```\r\nsudo npm install -g kal\r\n```\r\n\r\n`sudo` may not be required depending on how you installed `node`.\r\n\r\n## Syntax Highlighting\r\n\r\nA [TextMate bundle](https://github.com/rzimmerman/kal.tmbundle) for TextMate and Sublime Text is available with limited but very useful support for Kal's syntax.\r\n\r\n## Installing from the Repository\r\n\r\n[![Build Status](https://secure.travis-ci.org/rzimmerman/kal.png?branch=master)](https://travis-ci.org/rzimmerman/kal)\r\n\r\nIf you need the latest and greatest (possibly unstable/broken) build, you can build Kal manually. Most users can skip this section and just use the latest `npm` version.\r\n\r\nKal is written in Kal, so you need a prebuilt version of the compiler available to do the initial build:\r\n\r\n```\r\nsudo npm install -g kal\r\n```\r\n\r\nThen you can clone and build the repo:\r\n\r\n```\r\ngit clone https://github.com/rzimmerman/kal kal\r\ncd kal\r\nnpm run-script make\r\n```\r\n\r\nRun the tests to make sure everything is going well:\r\n\r\n```\r\nnpm test\r\n```\r\n\r\nIf you're extra serious, you can use your new build to rebuild itself in case there were any notable changes to the compiler between the npm release and the latest commit. This will also run the tests.\r\n\r\n```\r\nnpm run-script bootstrap\r\n```\r\n\r\nNow install your latest version using npm:\r\n\r\n```\r\nnpm pack\r\n```\r\n\r\nAssuming the tests pass, this will make an archive file that you can install (the filename depends on the version):\r\n\r\n```\r\nsudo npm install -g kal-0.x.x.tgz\r\n```\r\n\r\nAlternatively you can just run the `scripts/kal` file if you don't want to install it globally.\r\n\r\n## Usage\r\n\r\nIf you installed Kal globally (using the `-g` option), you can run the interactive shell by running `kal` with no arguments.\r\n\r\n```\r\n$ kal\r\nkal> 'hello' + ' ' + 'world'\r\n'hello world'\r\n```\r\n\r\nYou can use the kal utility to run or compile files. Run `kal -h` for the full option set. If you installed kal locally (didn't use the -g option), you will need to specify the path to the kal executable, usually located at `node_modules/kal/scripts/kal`.\r\n\r\n```\r\nkal path/to/file.kal                                            --runs the specified file\r\nkal -o path/for/output path/to/file1.kal path/to/file2.kal ...  --compiles all files/directories listed to javascript\r\n                                                                  and writes the output into the folder specified by -o\r\n```\r\n\r\nUsing the `-j` or `--javascript` switches will show the output of the compiler.\r\n\r\nIf you import Kal in your Javascript code, it installs a compile hook that allows you to directly import .kal files:\r\n\r\n```javascript\r\nrequire('kal');\r\nrequire('./mykalfile'); //refers to mykalfile.kal\r\n```\r\n\r\n## Whitespace and Indentation\r\n\r\nIn Kal, spaces for indentation are significant and tabs are not valid. Indents are required for function definitions and blocks of code inside of `if` statements, `try`/`catch` blocks, and loops.\r\n\r\nYou should use two spaces to denote an indent. You can technically use any multiple of two spaces, but two is recommended stylistically. Any whitespace on blank lines is ignored. Semicolons at the end of statements are not required nor are they valid.\r\n\r\nIn general single statements cannot contain line breaks. Notable exceptions are list and object definitions. For example:\r\n\r\n```kal\r\na = [1, 2,\r\n    3,\r\n    4]\r\n\r\nb = {a:1\r\n     c:2}\r\n```\r\n\r\nWill work, however:\r\n\r\n```kal\r\na = 1 +\r\n    1\r\n```\r\n\r\nIs invalid. Future versions may include better support for line breaks within statements.\r\n\r\n## Comments\r\n\r\nComments are preceeded by a `#` sign. Anything after the `#` on the line will be ignored.\r\n\r\n```kal\r\nprint 5 #this is a comment\r\n```\r\n\r\nMultiline comments are enclosed by `###`:\r\n\r\n```kal\r\n###\r\nA multiline\r\ncomment\r\n###\r\n```\r\n\r\n## Functions and Tasks\r\n\r\n**Functions** are defined with an optional name and a list of arguments.\r\n\r\n```kal\r\nfunction my_function(arg1, arg2)\r\n  return arg1 + arg2\r\n```\r\n\r\nand\r\n\r\n```kal\r\nmy_function = function (arg1, arg2)\r\n  return arg1 + arg2\r\n```\r\n\r\nBoth define a variable `my_function` that takes two arguments and returns their sum. CoffeeScript syntax is also valid:\r\n\r\n```kal\r\nmy_function = (arg1, arg2) ->\r\n  return arg1 + arg2\r\n```\r\n\r\nBut is generally discouraged unless it significantly helps readability. It was originally included to ease porting of the Kal compiler from CoffeeScript to Kal. Coffee-style functions must contain a line break after the `->`. `=>` is not supported.\r\n\r\nFunctions are called using parentheses.\r\n\r\n```kal\r\nmy_function(1, 2)\r\n```\r\n\r\nWill return `3`. Parentheses are optional if the function has at least one argument:\r\n\r\n```kal\r\nmy_function 1, 2\r\n```\r\n\r\nIs also valid. Function calls can be chained this way as well, so any of the following\r\n\r\n```kal\r\nprint(my_function(1,2))\r\nprint my_function 1, 2\r\nprint my_function(1, 2)\r\n```\r\n\r\nwill all print `3`. When calling a function with no arguments, parentheses are required.\r\n\r\n**Tasks** are similar to functions, except that they are intended to be called asynchronously (usually using a `wait for` statement).\r\n\r\n```kal\r\ntask my_task(arg)\r\n  return arg * 2\r\n```\r\n\r\nor\r\n\r\n```kal\r\nmy_task = task (arg)\r\n  return arg * 2\r\n```\r\n\r\nTasks should not be called synchronously. If a task is called synchronously, it will return with no value. When called asynchronously.\r\n\r\n```kal\r\nprint my_task 1\r\n```\r\n\r\nIs valid syntax, but will print `undefined`.\r\n\r\n```kal\r\nwait for x from my_task(1)\r\nprint x\r\n```\r\n\r\nWill print `2` as expected. See the `wait for` section for more details on asynchronous calls.\r\n\r\n## Objects and Arrays\r\n\r\nObjects and arrays are defined similarly to JavaScript. Newlines **are** valid inside of an array or object definition and indentation is ignored. Commas are optional when followed by a newline. CoffeeScript style object definitions (no `{}`s) are only valid in assignments and must be preceded by a newline.\r\n\r\n```kal\r\na = [1, 2, 3]\r\nb = [1\r\n     2,\r\n     3\r\n     4]\r\nc = {a:1,b:2,c:{d:3}}\r\nd =\r\n  a:1, b:2\r\n  c:\r\n    d:3\r\n```\r\n\r\nObjects work like JavaScript objects (because they are JavaScript objects), so you can access members either using array subscripts or `.` notation\r\n\r\n```kal\r\nx =\r\n  a : 1\r\n  b : 2\r\nprint x['a'] #prints 1\r\nprint x.b    #prints 2\r\n```\r\n\r\n## Scoping\r\n\r\nVariables are declared automatically and scoped within the current function unless used globally (like CoffeeScript).\r\n\r\nBy default, nothing in your `.kal` file will leak to the global scope. Everything is wrapped within a function scope inside the module. If you need to export variables to global scope, you should use\r\n\r\n```kal\r\nmodule.exports.my_export = my_variable_or_function # in node.js\r\nwindow.my_export = my_variable_or_function         # in a browser\r\n```\r\n\r\n_or_ you can compile the file with the `--bare` option.\r\n\r\n## Conditionals\r\n\r\nThe following defines a conditional statement:\r\n\r\n```kal\r\nx = 5\r\nif x is 5\r\n  print 'five'\r\n```\r\n\r\nwill print `five`.\r\n\r\n```kal\r\nx = 6\r\nif x is 5\r\n  print 'five'\r\nelse\r\n  print 'not five'\r\n```\r\n\r\nwill print `not five`\r\n\r\nThe conditional has useful synonyms:\r\n\r\n* `when` is equivalent to `if`\r\n* `unless` is equivalent to `if not`\r\n* `except when` is equivalent to `if not`\r\n* `otherwise` is equivalent to `else`\r\n\r\nSo the following is valid, as are other permutations:\r\n\r\n```kal\r\nunless name is 'Steve'\r\n  print 'Impostor!'\r\notherwise\r\n  print 'Steve'\r\n```\r\n\r\n`else` (and synonyms) can be chained with `if` (and synonyms), so\r\n\r\n```kal\r\nif name is 'Steve'\r\n  print 'Steve'\r\nelse if name is 'Brian'\r\n  print 'Brian'\r\notherwise when name is 'Joe'\r\n  print 'Joe'\r\nelse\r\n  print 'Somebody'\r\n```\r\n\r\nis valid.\r\n\r\nConditionals can also tail a statement:\r\n\r\n```kal\r\nprint 5 if 5 > 10\r\n```\r\n\r\nwill do nothing.\r\n\r\nConditionals can be used in a ternary statement as well\r\n\r\n```kal\r\nprint(5 if name is 'Joe' otherwise 6)\r\n```\r\n\r\nwill print `5` if the variable name is equal to `'Joe'`, otherwise it will print `6`. Kind of like it says. Parentheses are required because tail conditionals associate right, meaning the following are equivalent:\r\n\r\n```kal\r\nprint 5 if name is 'Joe' otherwise 6\r\n(print(5) if name is 'Joe') otherwise 6\r\n```\r\n\r\n## Loops\r\n\r\n`for` loops work as follows:\r\n\r\n```kal\r\nfor x in [1,2,3]\r\n  print x\r\n```\r\n\r\nWill print the numbers 1, 2, and 3. The value n the right of the `for ... in` expression is called the `iterant`. It must either be an array. Python-like iterable object support is coming soon.\r\n\r\n`for` loops can also be used on objects:\r\n\r\n```kal\r\nobj = {a:1,b:2}\r\nfor key of obj\r\n  print key, obj[key]\r\n```\r\n\r\nWill print `a 1` and `b 2`.\r\n\r\nWhen used on asynchronous code, the `parallel` and `series` specifiers are available:\r\n\r\n```kal\r\nfor parallel x in y\r\n  wait for z from f(x)\r\n\r\nfor series x in y\r\n  wait for z from f(x)\r\n```\r\n\r\n`series` is the default if neither is specified. Parallel for loops are **not** guaranteed to execute in order! In fact, they often won't. Take special care when accessing variables separated by `wait for` asynchronous statements. Remember that a `wait for` releases control of execution, so other loop iterations running in parallel may alter local variables if you are not careful. See the `wait for` section for more details.\r\n\r\n`while` loops continuously run their code block until a condition is satisfied.\r\n\r\n```kal\r\nx = 0\r\nwhile x < 5\r\n  x += 1\r\n  print x\r\n```\r\n\r\nprints the numbers 1 through 5.\r\n\r\n## Comprehensions\r\n\r\nList comprehensions are a quick and useful way to create an array from another array:\r\n\r\n```kal\r\ny = [1,2,3]\r\nx = [value * 2 for value in y]\r\n```\r\n\r\nwill set `x` equal to `[2,4,6]`. Comprehensions also support an iterable object. Iterable objects support a `next()` method which returns the next value in the sequence each time it is called. When there are no more values in the sequence, it should return `null`.\r\n\r\n```kal\r\nclass RandomList:\r\n  method initialize(size)\r\n    me.counter = size\r\n  method next()\r\n    me.counter -= 1\r\n    if me.counter >= 0\r\n      return Math.random()\r\n    else\r\n      return null\r\n\r\nx = [r * 10 for r in new RandomList(20)]\r\n```\r\n\r\nwill set `x` to an array of 20 random numbers between 0 and 10.\r\n\r\nList comprehensions work on objects, too:\r\n\r\n```kal\r\nobj = {a:1, b:2}\r\nx = [p for property p in obj]               # ['a','b']\r\nx = [v for property value v in obj]         # [1, 2]\r\nx = [p+v for propert p with value v in obj] # ['a1', 'b2']\r\n```\r\n\r\nConditionals in list comprehensions are coming soon.\r\n\r\n## Operators And Constants\r\n\r\nListed below are Kal's operators and their other-language equivalents. Note that Kal has a lot of synonyms for some keywords, all of which compile to the same function.\r\n\r\n| Kal                        | CoffeeScript         | JavaScript           | Function                       |\r\n|:--------------------------:|:--------------------:|:--------------------:|--------------------------------|\r\n| `true`, `yes`, `on`        | `true`, `yes`, `on`  | `true`               | Boolean true                   |\r\n| `false`, `no`, `off`       | `false`, `no`, `off` | `false`              | Boolean false                  |\r\n| `and`, `but`               | `and`                | `&&`                 | Boolean and                    |\r\n| `or`                       | `or`                 | `||`                 | Boolean or                     |\r\n| `nor`                      | none                 | none                 | Boolean or, inverted           |\r\n| `xor`                      | `^`                  | `^`                  | Bitwise xor                    |\r\n| `bitwise and`*             | `&`                  | `&`                  | Bitwise and                    |\r\n| `bitwise or`*              | `|`                  | `|`                  | Bitwise or                     |\r\n| `^`                        | none                 | none                 | Exponent (`Math.pow`)          |\r\n| `exists`, `?`              | `?`                  | none                 | Existential check              |\r\n| `doesnt exist`             | none                 | none                 | Existential check (inverted)   |\r\n| `is`, `==`                 | `is`, `==`           | `===`                | Boolean equality               |\r\n| `isnt`, `!=`               | `isnt`, `==`         | `!==`                | Boolean inequality             |\r\n| `>`, `>=`, `<`, `<=`       | `>`, `>=`, `<`, `<=` | `>`, `>=`, `<`, `<=` | Boolean comparisons            |\r\n| `me`, `this`               | `@`, `this`          | `this`               | Current object                 |\r\n| `in`                       | `in`                 | none                 | Boolean search of array/string |\r\n| `of`                       | `of`                 | `in`                 | Boolean search of object       |\r\n| `nothing`, `empty`, `null` | `null`               | `null`               | Null value                     |\r\n| `undefined`                | `undefined`          | `undefined`          | no value                       |\r\n| `instanceof`               | `instanceof`         | `instanceof`         | inheritance check              |\r\n| `print`                    | `console.log`        | `console.log`        | alias for `console.log`        |\r\n\r\n## Exisential Checks\r\n\r\nKal implements the same existential operator features of CoffeeScript, with the addition of the `exists` and `doesnt exist` keyword suffixes, which perform the same function as the `?` operator. Examples:\r\n\r\n```kal\r\na = {a:1}\r\nb = [1,2,3]\r\n\r\nprint(c exists) # false\r\nprint(c doesnt exist) #true\r\nprint(c?) #false\r\n\r\nprint(c.something) #throws an error!\r\nprint(c?.something) #prints undefined\r\n\r\nprint(a?.a) # 1\r\nprint(a?.a?) # true\r\nprint(b?[2]) # 3\r\n\r\nprint c() # error!\r\nprint c?() # prints undefined\r\n```\r\n\r\n## Classes and Inheritence\r\n\r\nClasses are defined with member `method` definitions. Methods are just functions that are added to the prototype of new instance objects (in other words, they are available to all instances of a class). The `initialize` method, if present, is used as the constructor when the `new` keyword is used. `me` (or its synonym `this`) is used in methods to access the current instance of the class. `instanceof` checks if an object is an instance of a class.\r\n\r\n```kal\r\nclass Person\r\n  method initialize(name)\r\n    me.name = name\r\n  method printName()\r\n    print me.name\r\n  method nameLength()\r\n    return me.name.length\r\n\r\njen = new Person('Jen')\r\njen.printName() # prints 'Jen'\r\nprint(jen instanceof Person) # prints true\r\n```\r\n\r\nClasses can inherit from other classes and override or add to their method definitions. The `super` keyword can be used in a method to call the same function in the parent class.\r\n\r\n```kal\r\nclass FrumpyPerson inherits from Person\r\n  method printName()\r\n    print 'Frumpy ' + me.name\r\n  method nameLength()\r\n    return 0\r\n\r\nsue = new FrumpyPerson('Sue')\r\nsue.printName() # prints 'Frumpy Sue'\r\nprint(sue instanceof Person) # prints true\r\nprint(sue instanceof FrumpyPerson) # prints true\r\nprint(jen instanceof FrumpyPerson) # prints false\r\n```\r\n\r\n## Try/Catch\r\n\r\n`try` and `catch` blocks work similarly to JavaScript/CoffeeScript. `finally` blocks are not supported yet but are coming eventually. The `throw` statement (and its synonyms `raise` and `fail with`) work like JavaScript as well.\r\n\r\n```kal\r\ntry\r\n  a = 'horse' / 2 # what are we doing? this will throw an error!\r\n  b = 1 # never runs\r\ncatch e\r\n  print 'caught it!', e\r\n```\r\n\r\nThe `e` variable above stores the error object thrown with `throw` or by the system. You can give it any name you want and it is optional. The following is valid:\r\n\r\n```kal\r\ntry\r\n  throw 'a string'\r\n  b = 1 # never runs\r\ncatch\r\n  print 'caught it!'\r\n```\r\n\r\n`try`/`catch` blocks can be nested. `try` blocks can contain asynchronous `wait for` calls, but `catch` blocks cannot at this time.\r\n\r\n## Strings\r\n\r\nStrings can either be double-quoted (`\"`) or single quoted (`'`). Backslashes can be used to escape quotes within strings if necessary.\r\n\r\nDouble-quoted strings can contain interpolated values using `#{...}` blocks.\r\n\r\n```kal\r\nx = 'this is a \"string\" with quotes in it'\r\ny = \"so is 'this'\"\r\nz = 'this one is, \\'too\\' but I\\'m not proud of it'\r\nw = \"This is a string with the number 3: #{1+1+1}\"\r\n```\r\n\r\n## Regular Expressions\r\n\r\nKal supports JavaScripts regex syntax, but not CoffeeScript style block regex syntax.\r\n\r\n## Asynchronous Wait For\r\n\r\nThe `wait for` statement executes a `task` and pauses execution (yielding to the runtime) until the `task` is complete. The following reads a file asynchronously and prints its contents (in node.js).\r\n\r\n```kal\r\nfs = require 'fs'\r\nwait for data from fs.readFile '/home/user/file.txt'\r\nprint data.toString()\r\n```\r\n\r\nNote that:\r\n\r\n* For users familiar with node.js and JavaScript, `fs.readFile` is called with the file name argument and a callback. **You don't need to supply a callback.**\r\n* After the `wait for` line, execution is paused and other code can run. Keep this in mind if you have global variables that are modified asynchronously as they may change between the `wait for` line and the line after it.\r\n* Any errors reported by `fs.readFile` (returned via callback) **will be thrown automatically**. You should wrap the `wait for` in a `try`/`catch` if you want to catch these errors.\r\n\r\n`wait for` can be used to call your own asynchronous tasks. It can also be used within `for` and `while` loops, `try` blocks, `if` statements, and **any nesting combination** you can think of. Really!\r\n\r\n```\r\nfs = require 'fs'\r\ntask readFileSafe(filename)\r\n  if 'secret' in filename\r\n    throw 'Illegal Access!'\r\n  else\r\n    wait for d from fs.readFile filename\r\n    return d\r\n\r\nfor parallel filename in ['secret/data.txt', 'test.txt', 'test2.txt']\r\n  try\r\n    wait for data from readFileSafe '/home/secret/file.txt'\r\n    print data.toString()\r\n  catch error\r\n    print \"ERROR: #{error}\"\r\nprint 'DONE!'\r\n```\r\n\r\nSome node.js API functions (like `http.get`) don't follow the normal convention of calling back with an error argument. For these functions you must use the `safe` prefix, otherwise it will throw an error:\r\n\r\n```kal\r\nhttp = require 'http'\r\nsafe wait for request from http.get 'http://www.google.com'\r\nprint request.responseCode\r\n```\r\n\r\n`wait for` statements also support multiple return values\r\n\r\n```kal\r\nwait for a, b from my_task()\r\n```\r\n","google":"UA-43261810-1","note":"Don't delete this file! It's used internally to help with page regeneration."}