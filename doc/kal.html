<!DOCTYPE html>

<html>
<head>
  <title>kal.litkal</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="ast.html">
                ast.litkal
              </a>
            
              
              <a class="source" href="command.html">
                command.litkal
              </a>
            
              
              <a class="source" href="generator.html">
                generator.litkal
              </a>
            
              
              <a class="source" href="grammar.html">
                grammar.litkal
              </a>
            
              
              <a class="source" href="interactive.html">
                interactive.litkal
              </a>
            
              
              <a class="source" href="kal.html">
                kal.litkal
              </a>
            
              
              <a class="source" href="lexer.html">
                lexer.litkal
              </a>
            
              
              <a class="source" href="literate.html">
                literate.litkal
              </a>
            
              
              <a class="source" href="parser.html">
                parser.litkal
              </a>
            
              
              <a class="source" href="sugar.html">
                sugar.litkal
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>kal.litkal</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h2>The Kal Compiler</h2>

            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Kal is a highly readable, easy-to-use language that compiles to JavaScript. It&#39;s designed to be asynchronous and can run both on <a href="http://nodejs.org">node.js</a> and in the browser. Kal makes asynchronous programming easy and clean by allowing functions to pause and wait for I/O, replacing an awkward callback syntax with a clean, simple syntax.</p>
<p>The Kal compiler is written in Literate Kal. As a result, a “binary” (JavaScript) version is required to compile this source. You can obtain the latest precompiled package from npm using <code>npm install -g kal</code> (may require <code>sudo</code> depending on your setup). Once you have Kal installed globally, you can use the following scripts:</p>
<ul>
<li><code>npm run-script make</code> - This will compile the <code>sources</code> directory (this source) into the <code>compiled</code> directory.</li>
<li><code>npm test</code> - Run the test suite against the <code>compiled</code> directory. You must run <code>npm install</code> for this repository to install the developer dependencies first.</li>
<li><code>npm run-script bootstrap</code> - Build <code>sources</code> using the globally installed Kal compiler, then rebuild <code>sources</code> using the compiled version of itself. This also runs tests. This script is used to verify the compiler before deployment to npm.</li>
</ul>
<h1>Structure</h1>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>The compiler uses several stages to compile Kal code.</p>
<p>For Literate Kal files (like this one), the <code>literate</code> module strips out the leading spaces from code blocks and turns Markdown syntax (like this line) into comments.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>literate  = <span class="built_in">require</span> <span class="string">'./literate'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>The first stage is the lexer, which turns the raw string output into an array of tokens of various types (such as <code>IDENTIFIER</code>, <code>STRING</code>, and <code>NUMBER</code>).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>lexer     = <span class="built_in">require</span> <span class="string">'./lexer'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>The “sugar” stage handles syntactic sugar. This includes features that would be difficult to handle in the full parsing stage, such as function calls without parentheses, multiline lists, and CoffeeScript style function definitions. The result is a modified array of tokens that can be read by the parser.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>sugar     = <span class="built_in">require</span> <span class="string">'./sugar'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>The parser stage is uses a recursive descent parser to step through the token array and create a tree of objects representing the structure of the code (an Abstract Syntax Tree).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>parser    = <span class="built_in">require</span> <span class="string">'./parser'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>The generator stage turns the syntax tree into JavaScript by traversing the tree depth-first, asking each node to produce the JavaScript code that corresponds to its function. This adds methods to the classes in the parser for JavaScript generation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>generator = <span class="built_in">require</span> <span class="string">'./generator'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>This file maintains the version reported by <code>kal -v</code>. Unfortunately, this is not the same as the version listed in <code>package.json</code>, which is used to set the version reported by npm. Both this line and the <code>package.json</code> file need to be updated before an npm release.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="reserved">export</span>s.VERSION = <span class="string">'0.5.3'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <h1>Compilation</h1>

            </div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>The compile function takes a <code>code</code> parameter that can be a string or buffer. This is the raw Kal (or Literate Kal) code. It also takes an <code>options</code> object which <em>may</em> contain the following properties (all optional):</p>
<ul>
<li><code>bare</code> - if true, the resulting JavaScript will not be wrapped in a function wrapper. Top-level variables will leak to the global scope. The default is false (code is wrapped in a function).</li>
<li><code>literate</code> - compile as a Literate Kal file. The default is false (regular Kal).</li>
<li><code>show_tokens</code> - if true, the resulting token array is printed to <code>stdout</code>. This is useful for debugging the compiler. The default is false.</li>
</ul>
<p>Other members of <code>options</code> are ignored.</p>
<p>This function returns a string containing the compiled JavaScript including proper spacing and indentation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">compile</span><span class="params">(code, options)</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>If code is passed as a buffer, there can be issues with Unicode characters (gh-108). As a result we convert it explicitly to a string and remove any trailing whitespace or newlines.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  code = code.toString().trim()</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Files are wrapped in a function to prevent leakage to the global scope by default.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  options = {<span class="attribute">bare</span>:<span class="literal">no</span>} <span class="keyword">when</span> options <span class="keyword">doesnt</span> <span class="keyword">exist</span></pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Run through the Literate module (if necessary), then tokenize with the lexer. The lexer returns tokens and comments seperately. The token array is then run through the <code>sugar</code> module to handle hard-to-parse features.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">try</span>
    code = literate.translate code <span class="keyword">when</span> options.literate
    token_rv = lexer.tokenize code
    raw_tokens = token_rv[<span class="number">0</span>]
    comments   = token_rv[<span class="number">1</span>]
    tokens = sugar.translate_sugar raw_tokens, options, lexer.tokenize</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>We call the <code>js</code> method to recursively generate JavaScript from the tree, then return the value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    root_node = parser.parse tokens, comments, options
    <span class="keyword">return</span> root_node.js options</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>We want to throw a string here, otherwise the user won&#39;t see a useful error message at the terminal (just an error class name).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">catch</span> compile_error
    <span class="keyword">throw</span> compile_error.message <span class="keyword">or</span> compile_error

<span class="reserved">export</span>s.compile = compile</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <h1>Running Scripts (Eval)</h1>

            </div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>The <code>eval</code> function (called <code>kal_eval</code> locally to avoid conflicting with JavaScript&#39;s built-in <code>eval</code>) compiles a string of Kal code and runs it in the specified environment. All options in the <code>options</code> argument are passed through to <code>compile</code>. The <code>options</code> argument can contain the following other (optional) settings:</p>
<ul>
<li><code>show_js</code> - print the output JavaScript of <code>compile</code> to the console. Useful for debugging the compiler. The default is false.</li>
<li><code>sandbox</code> - if true, the code will be run in a separate (sandbox) environment with its own set of globals. If false or missing, the code will be run in the <code>global</code> context. Alternatively, you can specify an object that represents the global context in which the script should run.</li>
<li><code>modulename</code> - Passed to <code>makeSandbox</code>. If specified, the name of the module used when running the script. Default is <code>eval</code>.</li>
<li><code>filename</code> - Passed to <code>makeSandbox</code>. If specified, the name of the file used when running the script. Default is <code>eval</code>.</li>
</ul>
<p>Code passed to this function is run immediately.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">kal_eval</span><span class="params">(code, options)</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Compile the code object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  options = {} <span class="keyword">if</span> options <span class="keyword">doesnt</span> <span class="keyword">exist</span>
  js = compile code, options</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>Show the output JavaScript if the user asked us to. This is really just for compiler debugging.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="built_in">print</span> js <span class="keyword">when</span> options.show_js</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Node&#39;s <code>vm</code> module is used to run the script in a specified global context. This is the same technique CoffeeScript (and node) use to run scripts.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  vm   = <span class="built_in">require</span> <span class="string">'vm'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>If the a sandbox option was specified, either use the specified object as the sandbox or create a new one based on the current globals if the parameter is just <code>true</code>. Otherwise, just use the current global context.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> options.sandbox
    sandbox = <span class="reserved">export</span>s.makeSandbox(options) <span class="keyword">if</span> options.sandbox <span class="keyword">is</span> <span class="literal">yes</span> <span class="keyword">otherwise</span> options.sandbox
  <span class="keyword">else</span>
    sandbox = <span class="built_in">global</span></pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>If the sandbox context is the <code>global</code> object, run the script in this context. Otherwise, run it with the sandbox.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> sandbox <span class="keyword">is</span> <span class="built_in">global</span>
    <span class="keyword">return</span> vm.runInThisContext js
  <span class="keyword">else</span>
    <span class="keyword">return</span> vm.runInContext js, sandbox</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Export as just <code>eval</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="reserved">export</span>s.eval = kal_eval</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <h1>Sandboxes</h1>

            </div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>This function creates a sandbox with the specified options based on the current <code>global</code> object. It initializes the sandbox with the necessary require hooks and path variables. The <code>sandbox</code> argument can be a script context object (from the <code>vm</code> module), or just an object with global variables for a new context. If an object is passed through, this function will create the script context object automatically. This function uses the following (optional) values from the <code>options</code> argument:</p>
<ul>
<li><code>modulename</code> - If specified, the name of the module used when running the script. Default is <code>eval</code>.</li>
<li><code>filename</code> - If specified, the name of the file used when running the script. Default is <code>eval</code>.</li>
</ul>
<p>This function returns a <code>vm</code> script context object suitable for use with <code>vm.runInContext</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">makeSandbox</span><span class="params">(sandbox, options)</span></span>
  vm   = <span class="built_in">require</span> <span class="string">'vm'</span>
  path = <span class="built_in">require</span> <span class="string">'path'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Create a sandbox (<code>vm</code> script context object) based on the global environment if one is not specified. Otherwise, check if the specified sandbox is already a script context object. If not, we create a script context object based for it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> sandbox <span class="keyword">doesnt</span> <span class="keyword">exist</span>
    sandbox = vm.createContext(<span class="built_in">global</span>)
  <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">not</span> (sandbox <span class="keyword">instanceof</span> vm.Script.createContext().constructor) but sandbox <span class="keyword">isnt</span> <span class="built_in">global</span>
    new_sandbox = vm.createContext(<span class="built_in">global</span>)
    <span class="keyword">for</span> k <span class="keyword">of</span> sandbox
      new_sandbox[k] = sandbox[k]
    sandbox = new_sandbox</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>Set the <code>__filename</code> and <code>__dirname</code> that the script will see at run-time. We also set up the <code>module</code> and <code>require</code> objects to mimic what the script would see if it was run with <code>node</code> from the command line.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  sandbox.__filename = options?.filename <span class="keyword">or</span> <span class="string">'eval'</span>
  sandbox.__dirname  = path.dirname sandbox.__filename
  Module = <span class="built_in">require</span> <span class="string">'module'</span>
  _<span class="built_in">module</span>  = <span class="keyword">new</span> Module(options?.modulename <span class="keyword">or</span> <span class="string">'eval'</span>)
  sandbox.<span class="built_in">module</span>  = _<span class="built_in">module</span>
  <span class="function"><span class="title">_require</span> = <span class="params">(path)</span> -&gt;
</span>    <span class="keyword">return</span> Module._load path, _<span class="built_in">module</span>, <span class="literal">true</span>
  sandbox.<span class="built_in">require</span> = _<span class="built_in">require</span>
  _module.filename = sandbox.__filename
  <span class="keyword">for</span> r <span class="keyword">in</span> Object.getOwnPropertyNames(<span class="built_in">require</span>)
    <span class="keyword">if</span> r <span class="keyword">isnt</span> <span class="string">'paths'</span>
      _<span class="built_in">require</span>[r] = <span class="built_in">require</span>[r]</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>This is the same hack node and coffee currently uses for their own REPL.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  _module.paths = Module._nodeModulePaths process.cwd()
  _require.paths = _module.paths
  _require.<span class="function"><span class="title">resolve</span> = <span class="params">(request)</span> -&gt;
</span>    <span class="keyword">return</span> Module._resolveFilename request, _<span class="built_in">module</span>
  <span class="keyword">return</span> sandbox

<span class="reserved">export</span>s.makeSandbox = makeSandbox</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <h1>Require Extentions</h1>

            </div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>This segment adds extensions to node&#39;s <code>require</code> function for Kal and Literate Kal files so that you can just <code>require</code> a Kal file without having to compile it first (assuming your script has already run <code>require &#39;kal&#39;</code>).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">if</span> require.extensions
  <span class="function"><span class="title">extension</span> = <span class="params">(<span class="built_in">module</span>, filename)</span> -&gt;
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>Check if this is a Literate Kal file.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    is_literate = <span class="built_in">require</span>(<span class="string">'path'</span>).extname(filename) <span class="keyword">in</span> [<span class="string">'.litkal'</span>, <span class="string">'.md'</span>]</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Read the file, then compile using the <code>compile</code> function above. Then use node&#39;s built-in compile function to compile the JavaScript.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    content = compile(<span class="built_in">require</span>(<span class="string">'fs'</span>).readFileSync(filename, <span class="string">'utf8'</span>),{<span class="attribute">filename</span>:filename, <span class="attribute">literate</span>:is_literate})
    module._compile(content, filename)</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>Add the extension for all appropriate file types. Don&#39;t overwrite <code>.md</code> in case CoffeeScript or something else is already using it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  require.extensions[<span class="string">'.kal'</span>]    = extension
  require.extensions[<span class="string">'.litkal'</span>] = extension
  require.extensions[<span class="string">'.md'</span>]     = extension <span class="keyword">except</span> <span class="keyword">when</span> require.extensions[<span class="string">'.md'</span>] <span class="keyword">exists</span></pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
