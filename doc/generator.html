<!DOCTYPE html>

<html>
<head>
  <title>generator.litkal</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="ast.html">
                ast.litkal
              </a>
            
              
              <a class="source" href="command.html">
                command.litkal
              </a>
            
              
              <a class="source" href="generator.html">
                generator.litkal
              </a>
            
              
              <a class="source" href="grammar.html">
                grammar.litkal
              </a>
            
              
              <a class="source" href="interactive.html">
                interactive.litkal
              </a>
            
              
              <a class="source" href="kal.html">
                kal.litkal
              </a>
            
              
              <a class="source" href="lexer.html">
                lexer.litkal
              </a>
            
              
              <a class="source" href="literate.html">
                literate.litkal
              </a>
            
              
              <a class="source" href="parser.html">
                parser.litkal
              </a>
            
              
              <a class="source" href="sugar.html">
                sugar.litkal
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>generator.litkal</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h2>Kal Generator</h2>

            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>The <code>generator</code> module extends parser abstract syntax tree classes. It provides methods for generating JavaScript code for each node by traversing the tree. The compiler calls the <code>.js()</code> method of the root object to return the compiled JavaScript for the tree.</p>
<p>We extend the grammar classes, so this module needs to be loaded <strong>after</strong> the <code>grammar</code> module.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Grammar = <span class="built_in">require</span>(<span class="string">'./grammar'</span>).Grammar</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <h1>Keyword Mapping</h1>

            </div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Many keywords can be easily mapped one-to-one with their JavaScript equivalents.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>KEYWORD_TRANSLATE =
  <span class="string">'yes'</span>:        <span class="string">'true'</span>
  <span class="string">'on'</span>:         <span class="string">'true'</span>
  <span class="string">'no'</span>:         <span class="string">'false'</span>
  <span class="string">'off'</span>:        <span class="string">'false'</span>
  <span class="string">'is'</span>:         <span class="string">'==='</span>
  <span class="string">'isnt'</span>:       <span class="string">'!=='</span>
  <span class="string">'=='</span>:         <span class="string">'==='</span>
  <span class="string">'!='</span>:         <span class="string">'!=='</span>
  <span class="string">'and'</span>:        <span class="string">'&amp;&amp;'</span>
  <span class="string">'but'</span>:        <span class="string">'&amp;&amp;'</span>
  <span class="string">'or'</span>:         <span class="string">'||'</span>
  <span class="string">'xor'</span>:        <span class="string">'^'</span>
  <span class="string">'^'</span>:          <span class="string">'pow'</span>
  <span class="string">'mod'</span>:        <span class="string">'%'</span>
  <span class="string">'not'</span>:        <span class="string">'!'</span>
  <span class="string">'new'</span>:        <span class="string">'new'</span>
  <span class="string">'me'</span>:         <span class="string">'this'</span>
  <span class="string">'this'</span>:       <span class="string">'this'</span>
  <span class="string">'null'</span>:       <span class="string">'null'</span>
  <span class="string">'nothing'</span>:    <span class="string">'null'</span>
  <span class="string">'none'</span>:       <span class="string">'null'</span>
  <span class="string">'break'</span>:      <span class="string">'break'</span>
  <span class="string">'throw'</span>:      <span class="string">'throw'</span>
  <span class="string">'raise'</span>:      <span class="string">'throw'</span>
  <span class="string">'instanceof'</span>: <span class="string">'instanceof'</span>
  <span class="string">'of'</span>:         <span class="string">'in'</span>
  <span class="string">'EndOfList'</span>:  <span class="string">'undefined'</span>
  <span class="string">'fail'</span>:       <span class="string">'throw'</span>
  <span class="string">'bitwise and'</span>:   <span class="string">'&amp;'</span>
  <span class="string">'bitwise or'</span>:    <span class="string">'|'</span>
  <span class="string">'bitwise xor'</span>:   <span class="string">'^'</span>
  <span class="string">'bitwise not'</span>:   <span class="string">'~'</span>
  <span class="string">'typeof'</span>:        <span class="string">'typeof'</span>
  <span class="string">'bitwise left'</span>:  <span class="string">'&lt;&lt;'</span>
  <span class="string">'bitwise right'</span>: <span class="string">'&gt;&gt;'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <h1>Globals</h1>

            </div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>These globals are reset each time a <code>File</code> object&#39;s <code>js</code> method is called.</p>
<p>Scope is tracked using a mapping from variable names to scope qualifier strings. Qualifier strings include:</p>
<ul>
<li><code>closures ok</code> - A “normal” variable that will not be redefined if used in a child scope. Instead its closure will be used. This lets the compiler know this variable is new and needs a <code>var</code> definition in this scope.</li>
<li><code>closure</code> - A “normal” that was used in a parent scope and was passed through as a closure. This lets the compiler know this variable is already defined and it does not need a <code>var</code> definition in this scope.</li>
<li><code>no closures</code> - This variable is valid in the current scope and should be redefined if used in child scopes. This is used for iterator variables, temporary variables for return values, and callback function variables.</li>
<li><code>argument</code> - This is for function arguments. Arguments <em>are</em> passed through to child scopes but <em>do not</em> get <code>var</code> definitions in the local scope.</li>
<li><code>function</code> - Function definitions <em>are</em> passed through to child scopes but <em>do not</em> need <code>var</code> definitions in the local scope.</li>
<li><code>class definition</code> - Class definitions <em>are</em> passed through to child scopes but <em>do not</em> need <code>var</code> definitions in the local scope.</li>
</ul>
<p><code>scopes</code> represents the current scope stack.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>scopes = []
scope = {}</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Try blocks are maintained in a stack for asynchronous error handler generation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>try_block_stack = []
try_block_stacks = []</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p><code>parfor_cb</code> and it&#39;s stack are used to store the callback for any parallel <code>for</code> loops currently being generated.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>parfor_cb = <span class="literal">null</span>
parfor_cb_stack = []</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>The <code>current_callback</code> is the function to call upon exiting the current asynchronous block. For example, <code>if</code> statements with async members must call this function at all exit paths to make sure that code following the <code>if</code> block is executed. For example, in:</p>
<pre>
if flag
  wait for x from y()
else
  x = 2
</pre>

<p>The <code>if</code> block will need to wrap <code>print x</code> in a callback function. Every branch of the <code>if</code> statement needs to execute this callback somehow, even if it&#39;s just as a function call (like for the <code>else</code> block).</p>
<p>Callbacks get unique names throughout the file.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>callback_counter = <span class="number">0</span>
current_callback = <span class="string">"k$cb0"</span>
current_callbacks = []</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>The <code>comments</code> stream stores the comments from the original code that have not been inserted into the JavaScript output yet.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>comments = []</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>The current class being defined is tracked in a stack (classes can technically be definined inside other class definitions). The <code>class_def</code> object stores the class name and code that occurs directly in the definition that gets thrown in the constructor later.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>class_defs = []
class_def = {}</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>The literate flag is set for Literate Kal files. It is used to determine how comments, or in this case inline documentation lines, are formatted in the JavaScript output.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>literate = <span class="literal">no</span></pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Counters used to generate unique iterator variables for loops.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>for_count = <span class="number">1</span>
while_count = <span class="number">1</span></pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Snippets are useful chunks of JavaScript that are only included in the output when they are actually used.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>use_snippets = {}</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <h1>Utility Functions</h1>

            </div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>These functions indent a block of JavaScript to make it pretty.</p>
<p>Indent JavaScript with two spaces:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">indent</span><span class="params">(code)</span></span>
  <span class="keyword">if</span> code <span class="keyword">isnt</span> <span class="string">''</span>
    <span class="keyword">return</span> <span class="string">'  '</span> + code.replace(<span class="regexp">/\n(?![\r\n]|$)/g</span>, <span class="string">'\n  '</span>)
  <span class="keyword">else</span>
    <span class="keyword">return</span> code</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Indent JavaScript with <code>level * 2</code> spaces.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">multi_indent</span><span class="params">(code, level)</span></span>
  <span class="keyword">if</span> code <span class="keyword">isnt</span> <span class="string">''</span> <span class="keyword">and</span> level &gt; <span class="number">0</span>
    new_str = Array(level*<span class="number">2</span>+<span class="number">1</span>).join(<span class="string">' '</span>)
    <span class="keyword">return</span> new_str + code.replace(<span class="regexp">/\n(?![\r\n]|$)/g</span>, <span class="string">'\n'</span> + new_str)
  <span class="keyword">else</span>
    <span class="keyword">return</span> code</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Return a new unique callback function name.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">create_callback</span><span class="params">()</span></span>
  callback_counter += <span class="number">1</span>
  current_callback = <span class="string">"k$cb<span class="subst">#{callback_counter}</span>"</span>
  <span class="keyword">return</span> current_callback</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>Define a new class and push the current one to the stack.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">push_class</span><span class="params">()</span></span>
  class_defs.push class_def
  class_def = {<span class="attribute">name</span>: <span class="string">''</span>, <span class="attribute">code</span>: <span class="string">''</span>,<span class="attribute">args</span>: [],<span class="attribute">has_constructor</span>: <span class="literal">no</span>}</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Finish a class definition and pop the stack.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">pop_class</span><span class="params">()</span></span>
  class_def = class_defs.pop()
  <span class="keyword">return</span> class_def</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p><code>push_scope</code> is used to start a new function definition.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">push_scope</span><span class="params">()</span></span>
  scopes.push scope</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>It also creates a new context for <code>try</code> blocks.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  try_block_stacks.push try_block_stack
  try_block_stack = []</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Closeout callbacks are also saved for when we pop the scope.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  parfor_cb_stack.push parfor_cb
  parfor_cb = <span class="literal">null</span>
  current_callbacks.push current_callback</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>We copy in variables to the new scope as long as they are not marked <code>&quot;no closures&quot;</code>. We mark all of these as <code>&quot;closure&quot;</code> variables in the new scope so that they don&#39;t get a <code>var</code> definition inside the new scope.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  new_scope = {}
  <span class="keyword">for</span> k <span class="keyword">of</span> scope
    v = scope[k]
    <span class="keyword">if</span> v <span class="keyword">is</span> <span class="string">'no closures'</span>
      <span class="keyword">pass</span>
    <span class="keyword">else</span> <span class="keyword">if</span> v <span class="keyword">is</span> <span class="string">'closures ok'</span> <span class="keyword">or</span> v <span class="keyword">is</span> <span class="string">'argument'</span> <span class="keyword">or</span> v <span class="keyword">is</span> <span class="string">'function'</span>
      new_scope[k] = <span class="string">'closure'</span>
    <span class="keyword">else</span> <span class="keyword">if</span> v <span class="keyword">is</span> <span class="string">'closure'</span>
      new_scope[k] = <span class="string">'closure'</span>
  scope = new_scope</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p><code>pop_scope</code> finishes out a function definition. It prepends the <code>code</code> argument with <code>var</code> definitions for variables that need them. If <code>wrap</code> is true, it will also wrap the code in a function to prevent leaks to the global scope.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">pop_scope</span><span class="params">(code, wrap)</span></span>
  rv = <span class="string">""</span></pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p><code>var_names</code> is a list of variables that need to be declared in this scope. We don&#39;t redeclare closures, function arguments, functions, or classes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  var_names = []
  <span class="keyword">for</span> var_name <span class="keyword">of</span> scope
    <span class="keyword">if</span> <span class="keyword">not</span> (scope[var_name] <span class="keyword">in</span> [<span class="string">'closure'</span>, <span class="string">'argument'</span>, <span class="string">'function'</span>, <span class="string">'class definition'</span>]) <span class="keyword">and</span> var_name <span class="keyword">isnt</span> <span class="string">'k$next'</span>
      var_names.push(var_name)</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>Wrap the function in a <code>(function () {...})()</code> wrapper if requested.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> wrap
    rv += <span class="string">'(function () {\n'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>If we have variables to declare, add a <code>var</code> statement for JavaScript.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> var_names.length &gt; <span class="number">0</span>
    code = <span class="string">'var '</span> + var_names.join(<span class="string">', '</span>) + <span class="string">';\n'</span> + code</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>Indent if we are in the wrapper.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  rv += indent(code) <span class="keyword">if</span> wrap <span class="keyword">otherwise</span> code</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>Close out the wrapper if present.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> wrap
    rv += <span class="string">"})()"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>Actually pop the scope (if we aren&#39;t at the top level), <code>try</code> context, and callback pointers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  scope = scopes.pop() <span class="keyword">except</span> <span class="keyword">when</span> scopes <span class="keyword">is</span> []
  try_block_stack = try_block_stacks.pop()
  current_callback = current_callbacks.pop()
  parfor_cb = parfor_cb_stack.pop()
  <span class="keyword">return</span> rv</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p><code>check_existence_wrapper</code> wraps a variable access with a check to make sure it actually exists before accessing it. This is used with the <code>?</code>, <code>doesnt exist</code>, and <code>exists</code> operators.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">check_existence_wrapper</span><span class="params">(code, undefined_unary, invert)</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>An “undefined unary” (<code>undefined_unary</code> is true) refers to a simple variable access to an undeclared variable, for example <code>x = a</code> where <code>a</code> is not defined in the current scope. This case requres we check if the variable exists before checking if it is null/undefined. Comparing directly to <code>null</code> would fail if the variable wasn&#39;t defined, so we do a <code>typeof ... === &#39;undefined&#39;</code> check first for this special case.</p>
<p><code>invert</code> indicates we should do a boolean invert of the check (check that it doesn&#39;t exist). The output code looks cleaner if we handle this seperately rather than using a <code>!</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> undefined_unary
    rv = <span class="string">"(typeof <span class="subst">#{code}</span> === 'undefined' || <span class="subst">#{code}</span> === null)"</span> <span class="keyword">when</span> invert <span class="keyword">otherwise</span> <span class="string">"(typeof <span class="subst">#{code}</span> !== 'undefined' &amp;&amp; <span class="subst">#{code}</span> !== null)"</span>
  <span class="keyword">else</span>
    rv = <span class="string">"<span class="subst">#{code}</span> == null"</span> <span class="keyword">when</span> invert <span class="keyword">otherwise</span> <span class="string">"<span class="subst">#{code}</span> != null"</span>
  <span class="keyword">return</span> rv</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p><code>kthis()</code> returns the current useable value for <code>me</code>. If we are in a callback or a task, this value gets stored in a <code>k$this</code> closure. Otherwise we just use <code>this</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">kthis</span><span class="params">()</span></span>
  <span class="keyword">return</span> (<span class="string">"k$this"</span> <span class="keyword">when</span> scope[<span class="string">'k$this'</span>] <span class="keyword">exists</span> <span class="keyword">otherwise</span> <span class="string">"this"</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p><code>render_try_blocks</code> will apply the current stack of <code>try</code> blocks. This is used when defining a new callback in order to carry error handling code through to the callback function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">render_try_blocks</span><span class="params">()</span></span>
  rv = <span class="string">""</span>
  indent_level = <span class="number">0</span>
  <span class="keyword">for</span> try_block <span class="keyword">in</span> try_block_stack
    rv += multi_indent(try_block.js_wrapper_try(), indent_level)
    indent_level += <span class="number">1</span>
  <span class="keyword">return</span> rv</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p><code>render_catch_blocks</code> will apply the current stack of <code>catch</code> blocks. This is used when defining a new callback in order to carry error handling code through to the callback function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">render_catch_blocks</span><span class="params">()</span></span>
  rv = <span class="string">""</span>
  indent_level = try_block_stack.length - <span class="number">1</span>
  <span class="keyword">for</span> try_block <span class="keyword">in</span> try_block_stack
    rv += multi_indent(try_block.js_wrapper_catch(), indent_level)
    indent_level -= <span class="number">1</span>
  <span class="keyword">return</span> rv</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <h1>JavaScript Generator Functions</h1>

            </div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <h3>File</h3>
<p><code>File</code> objects take an options argument (optional), that may contain the following entries:</p>
<ul>
<li><code>literate</code> - <code>true</code> if this file is Literate Kal. It changes the output style of the comments to look better for literate files.</li>
<li><code>bare</code> - if <code>true</code>, the output of this <code>File</code> will not get wrapped in a <code>function</code> wrapper and any module-level variables will leak to the global scope.</li>
</ul>
<p>This method also resets all the globals in this module.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">(options)</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">File</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>Global loop counters, flags, and stacks are reset here in case we are compiling multiple files.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  for_count = <span class="number">1</span>
  while_count = <span class="number">1</span>
  literate = options.literate
  scopes = []
  scope = {}
  try_block_stack = []
  try_block_stacks = []
  parfor_cb = <span class="literal">null</span>
  parfor_cb_stack = []
  callback_counter = <span class="number">0</span>
  current_callback = <span class="string">'k$cb0'</span>
  current_callbacks = []
  class_defs = []
  class_def = {<span class="attribute">name</span>: <span class="string">''</span>,<span class="attribute">code</span>: <span class="string">''</span>,<span class="attribute">args</span>: [],<span class="attribute">has_constructor</span>: <span class="literal">no</span>}
  use_snippets = {}
  me.callback = current_callback
  me.bare = options.bare</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>We consume the comments array later, so we make a copy in case the compiler needs it (not currently an issue).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  comments = [comment <span class="keyword">for</span> comment <span class="keyword">in</span> me.ts.comments]</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>We use the <code>Block</code> object‘s JavaScript generator for this node’s statements since this class acts like a block. <code>super</code> isn&#39;t supported as an expression yet, so this should wind up being something like <code>code = super()</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  code = Grammar.Block.prototype.js.apply <span class="literal">me</span></pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>We prepend any Kal JavaScript “snippets”. Snippets are useful pieces of code that only get included if used, such as code for the <code>in</code> operator.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  snip = []
  <span class="keyword">for</span> key <span class="keyword">of</span> use_snippets
    snip.push use_snippets[key]
  snip = snip.join <span class="string">'\n'</span>
  rv = [snip, code].join <span class="string">'\n'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>Close out any last callback (if present).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  rv += <span class="string">"}"</span> <span class="keyword">when</span> current_callback <span class="keyword">isnt</span> <span class="string">'k$cb0'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>Close out the scope and wrap with a function if necessary.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">return</span> pop_scope(rv, <span class="keyword">not</span> options.bare)</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <h3>Statement</h3>
<p><code>Statement</code> objects call their child node&#39;s <code>js</code> method and apply any comment tokens that apply to this segment of code.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">Statement</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>Pass all flags about our current state through to the child statement node.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  me.statement.in_conditional = me.in_conditional
  me.statement.in_loop = me.in_loop
  me.statement.parent_block = me.parent_block
  me.statement.callback = me.callback
  me.statement.original_callback = me.original_callback</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>Check for “postfix” comments. These are comments that occur at the end of the line, such as <code>a = 1 #comment</code>. We want to try to add these at the end of the current JavaScript line.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  comment_postfix = <span class="string">""</span>
  <span class="keyword">if</span> comments[<span class="number">0</span>] <span class="keyword">exists</span> <span class="keyword">and</span> comments[<span class="number">0</span>].line <span class="keyword">is</span> me.statement.line <span class="keyword">and</span> comments[<span class="number">0</span>].post_fix
    comment = comments.shift()
    comment_postfix = <span class="string">" /* <span class="subst">#{comment.<span class="keyword">value</span>}</span> */\n"</span>
  comment_prefix = <span class="string">""</span></pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>Check for “prefix” comments. These are comments that occur on their own line before the current line of code. There may be more than one, so we try to lump them all together into a big comment and prepend it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">while</span> comments[<span class="number">0</span>] <span class="keyword">exists</span> <span class="keyword">and</span> comments[<span class="number">0</span>].line &lt; me.statement.line
    comment = comments.shift()
    comment_prefix += <span class="string">"/* <span class="subst">#{comment.<span class="keyword">value</span>}</span> */"</span>
  comment_prefix = comment_prefix.replace <span class="regexp">/\*\/\/\*/g</span>, <span class="string">'\n  '</span> <span class="keyword">when</span> literate
  rv = me.statement.js()
  rv = rv.replace <span class="regexp">/\n/</span>, comment_postfix <span class="keyword">unless</span> comment_postfix <span class="keyword">is</span> <span class="string">''</span></pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>Add in newlines to make things look nice. Try not to add extra newlines.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> rv[<span class="number">0</span>] <span class="keyword">is</span> <span class="string">'\n'</span> <span class="keyword">and</span> comment_prefix <span class="keyword">isnt</span> <span class="string">""</span>
    rv = <span class="string">'\n'</span> + comment_prefix + rv
  <span class="keyword">else</span> <span class="keyword">if</span> comment_prefix <span class="keyword">isnt</span> <span class="string">""</span>
    rv = comment_prefix + <span class="string">'\n'</span> + rv
  <span class="keyword">return</span> rv</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <h3>ThrowStatement</h3>
<p><code>ThrowStatement</code>s are context-dependent. They require different code for asynchronous and synchronous blocks.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">ThrowStatement</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>If there is no local <code>try</code> block and we are in an asynchronous place, we call back with an error. Otherwise, we use a normal <code>throw</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> try_block_stack.length <span class="keyword">is</span> <span class="number">0</span> but scope[<span class="string">'k$next'</span>] <span class="keyword">exists</span>
    rv = <span class="string">"return k$next.apply(<span class="subst">#{kthis()}</span>, [<span class="subst">#{me.expr.js()}</span>]);\n"</span>
  <span class="keyword">else</span>
    rv = <span class="string">"throw <span class="subst">#{me.expr.js()}</span>;\n"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>Tail conditionals work with <code>throw</code> statements, so we apply one if specified.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  rv = me.conditional.js(rv, <span class="literal">no</span>) <span class="keyword">if</span> me.conditional?
  <span class="keyword">return</span> rv</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p><code>ThrowStatement</code>s are context-dependent. They require different code for asynchronous and synchronous blocks.</p>
<h3>ReturnStatement</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">ReturnStatement</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>Since return statements can have multiple return values, we generate JavaScript for each expression.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  exprs_js = [expr.js() <span class="keyword">for</span> expr <span class="keyword">in</span> me.exprs]</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>In asynchronous contexts, we need to prepend an error argument, in this case <code>null</code> since we are not throwing an error.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  exprs_js.unshift <span class="string">'null'</span> <span class="keyword">when</span> scope[<span class="string">'k$next'</span>] <span class="keyword">exists</span>
  arg_list = exprs_js.join(<span class="string">', '</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>In asynchronous contexts, we assign the return value array to a temporary variable and execute the callback.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> scope[<span class="string">'k$next'</span>] <span class="keyword">exists</span>
    scope[<span class="string">'k$rv'</span>] = <span class="string">'no closures'</span>
    use_snippets[<span class="string">'async'</span>] = snippets[<span class="string">'async'</span>]
    rv = <span class="string">"return k$rv = [<span class="subst">#{arg_list}</span>], k$async(k$next, <span class="subst">#{kthis()}</span>, k$rv);"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>We also wrap this in a conditional if specified.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rv = me.conditional.js(rv, <span class="literal">no</span>) <span class="keyword">when</span> me.conditional <span class="keyword">exists</span>
    rv += <span class="string">"\n"</span>
    <span class="keyword">return</span> rv
  <span class="keyword">else</span></pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>In a synchronous context, this turns into a simple <code>return</code> statement. If there are multiple return values, we return them as an array.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rv = <span class="string">"return"</span>
    <span class="keyword">if</span> me.exprs.length <span class="keyword">is</span> <span class="number">1</span>
      rv += <span class="string">" "</span> + arg_list
    <span class="keyword">else</span> <span class="keyword">if</span> me.exprs.length &gt; <span class="number">1</span>
      rv += <span class="string">"[<span class="subst">#{arg_list}</span>]"</span>
    rv += <span class="string">";\n"</span>
    rv = me.conditional.js(rv, <span class="literal">no</span>) <span class="keyword">when</span> me.conditional <span class="keyword">exists</span>
    <span class="keyword">return</span> rv</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <h3>ExpressionStatement</h3>
<p><code>ExpressionStatement</code>s are simply expressions wrapped as a statement, so we just return the child expression&#39;s JavaScript.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">ExpressionStatement</span></span>
  rv = me.expr.js()</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>We add newlines to make it look nice. Function definitions fall under this class, so we add extra newlines in that instance.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="string">""</span>
    <span class="keyword">return</span> <span class="string">""</span>
  <span class="keyword">else</span> <span class="keyword">if</span> me.expr.left.base <span class="keyword">instanceof</span> Grammar.FunctionExpression
    <span class="keyword">return</span> <span class="string">'\n'</span> + rv + <span class="string">'\n\n'</span>
  <span class="keyword">else</span>
    <span class="keyword">return</span> rv + <span class="string">';\n'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <h3>Expression</h3>
<p><code>Expression</code>s are not context-dependent with respect to asynchronous or synchronous blocks. By default, the parser just creates a tree with only one long branch when expressions are chained together. For example, <code>1 + 2 + 3</code>, turns into:</p>
<pre>
>   +
>  / \
> 1   +
>    / \
>   2   3
</pre>

<p>Which is normally fine because JavaScript has the same order of operations. However, certain operators in Kal don&#39;t match up one-for-one and need to have their precedence altered. The <code>in</code> and <code>^</code> operators are the only operators impacted at this time. For example, with <code>3 in a and 4 in b</code> gets parsed as:</p>
<pre>
>   in*
>  /  \
> 3   and**
>     / \
>    a+  in
>       / \
>      4   b
</pre>

<p>Because <code>in</code> gets turned into <code>k$indexof</code> function calls, we would get <code>k$indexof(3, a &amp;&amp; k$kindexof(4,b))</code>, which is clearly wrong. We need to convert the tree to:</p>
<pre>
>     and**
>    /    \
>   in*   in
>  / \    / \
> 3   a+ 4   b
</pre>

<p>If <code>oop_reverse</code> is specified, the current node (<code>*</code>) makes itself the left branch of it&#39;s own right branch (<code>**</code>). It then replaces it‘s own right branch with the old right branch’s left branch (<code>+</code>).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">(oop_reverse)</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">Expression</span></span>
  rv = <span class="string">''</span></pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>When <code>oop_reverse</code> is specified, my <code>left</code> object has already been compiled to a string and passed in with <code>oop_reverse</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> oop_reverse
    left_code = oop_reverse
  <span class="keyword">else</span>
    left_code = me.left.js()</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p>If this is not a binary expression, we just use the JavaScript from the left operand.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> me.op <span class="keyword">doesnt</span> <span class="keyword">exist</span>
    rv += left_code
  <span class="keyword">else</span></pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>Otherwise compile the operator.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    opjs = me.op.js()</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>The <code>in</code> operator gets replaced with a call to the <code>k$indexof</code> function. We mark the snipped as used and declare it in all scopes as a closure. I&#39;m pretty sure these steps are redundant (other than the <code>use_snippets</code> step).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> opjs <span class="keyword">is</span> <span class="string">'in'</span> <span class="keyword">and</span> me.op.op.<span class="keyword">value</span> <span class="keyword">isnt</span> <span class="string">'of'</span>
      <span class="keyword">unless</span> use_snippets[<span class="string">'in'</span>] <span class="keyword">exists</span>
        use_snippets[<span class="string">'in'</span>] = snippets[<span class="string">'in'</span>]
        <span class="keyword">for</span> subscope <span class="keyword">in</span> scopes
          subscope[<span class="string">'k$indexof'</span>] = <span class="string">'closure'</span>
        scope[<span class="string">'k$indexof'</span>] = <span class="string">'closure'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p>Do the order of operations reverse described above.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      old_right = me.right
      new_right = me.right.left
      new_left = <span class="string">"(k$indexof.call(<span class="subst">#{new_right.js()}</span>, <span class="subst">#{left_code}</span>) &gt;= 0)"</span>
      rv += old_right.js(new_left)</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>Nor gets a special case since we need to wrap the whole thing in a <code>!</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">else</span> <span class="keyword">if</span> opjs <span class="keyword">is</span> <span class="string">'nor'</span>
      rv += <span class="string">"!(<span class="subst">#{left_code}</span> || <span class="subst">#{me.right.js()}</span>)"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <p><code>pow</code> (<code>^</code>) needs to have it&#39;s order of operations reversed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">else</span> <span class="keyword">if</span> opjs <span class="keyword">is</span> <span class="string">'pow'</span>
      old_right = me.right
      new_right = me.right.left
      new_left = <span class="string">"Math.pow(<span class="subst">#{left_code}</span>, <span class="subst">#{new_right.js()}</span>)"</span>
      rv += old_right.js(new_left)</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>Otherwise, just generate code and let JavaScript handle order of operations.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">else</span>
      rv += <span class="string">"<span class="subst">#{left_code}</span> <span class="subst">#{opjs}</span> <span class="subst">#{me.right.js()}</span>"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p>For inverted expressions (those preceeded with a <code>not</code>), wrap it with a <code>!</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  rv = <span class="string">"!(<span class="subst">#{rv}</span>)"</span> <span class="keyword">if</span> me.op?.invert</pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p>Apply tail conditionals when appropriate.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  rv = me.conditional.js(rv, <span class="literal">yes</span>) <span class="keyword">if</span> me.conditional <span class="keyword">exists</span>
  <span class="keyword">return</span> rv</pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <h3>UnaryExpression</h3>
<p>Unary expressions are not context-dependent for asynchronous or synchronous contexts. These represent a single variable or constant, possibly with a chain of property access, array access, exisential, and/or function call operators.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">UnaryExpression</span></span>
  rv = <span class="string">''</span></pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <p>For identifiers, we attempt to tranlate the value if it is a keyword. For example, <code>yes</code> becomes <code>true</code>. If it&#39;s not a keyword, we just use it as-is.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> me.base.type <span class="keyword">is</span> <span class="string">'IDENTIFIER'</span>
    base_val = me.base.<span class="keyword">value</span>
    kw_translate = KEYWORD_TRANSLATE[base_val]</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <p><code>this</code> is a special case because we might be in a callback. <code>kthis</code> will give us the right value to use.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    kw_translate = kthis() <span class="keyword">when</span> kw_translate <span class="keyword">is</span> <span class="string">'this'</span>
    rv += kw_translate <span class="keyword">or</span> base_val</pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p>If it wasn‘t a keyword, we declare the variable in this scope if it has not been declared and is being used here as an l-value. We don’t do this if we are doing a compound assignment or if this unary has accessors (for example, <code>x.a = 1</code> does not declare <code>x</code>).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> kw_translate <span class="keyword">doesnt</span> <span class="keyword">exist</span> <span class="keyword">and</span> scope[base_val] <span class="keyword">doesnt</span> <span class="keyword">exist</span> <span class="keyword">and</span> me.is_lvalue() <span class="keyword">and</span> me.accessors.length <span class="keyword">is</span> <span class="number">0</span> but <span class="keyword">not</span> me.compound_assign
      scope[base_val] = <span class="string">'closures ok'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p>For constants we just pass the value through.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">else</span>
    rv += me.base.js()</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p>We do a check here to see if this is an “undefined unary”. An undefined unary is a simple variable access to an undeclared variable. When used with exisential operators, undefined unary&#39;s require a check if the variable exists before checking if it is <code>null</code> or <code>undefined</code> (<code>x == null</code> throws an error if <code>x</code> has never been defined).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  undefined_unary = (me.base.type <span class="keyword">is</span> <span class="string">'IDENTIFIER'</span> <span class="keyword">and</span> scope[base_val] <span class="keyword">doesnt</span> <span class="keyword">exist</span> <span class="keyword">and</span> kw_translate <span class="keyword">doesnt</span> <span class="keyword">exist</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <p>We need to build up a list of exisential qualifiers for each accessor. For example <code>x.a?.b</code> needs an exisential check wrapper for access to the <code>b</code> property. If there is no exisential for an accessor, it just returns an empty string.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  existence_qualifiers = []
  last_accessor = me.accessors[me.accessors.length-<span class="number">1</span>]
  <span class="keyword">for</span> accessor <span class="keyword">in</span> me.accessors
    existence_qualifiers.push accessor.js_existence rv, undefined_unary, last_accessor.invert</pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <p>Append the accessor (property access, function calls, array access, and/or exisentials) JavaScript.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rv += accessor.js()</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <p>Only the first access in a chain can be an undefined unary. <code>x?.a?.b</code> does not require that we check if <code>a</code> is defined before comparing it to <code>null</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    undefined_unary = <span class="literal">no</span></pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <p>Make a list of exisential checks, filtering out the empty ones. This will eventually be a list comprehension once they support conditionals.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  existence_check = []
  <span class="keyword">for</span> eq <span class="keyword">in</span> existence_qualifiers
    <span class="keyword">if</span> eq <span class="keyword">isnt</span> <span class="string">""</span>
      existence_check.push eq</pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <p>We join together all existence checks and wrap the current JavaScript with the check if necessary.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  existence_check = existence_check.join(<span class="string">' &amp;&amp; '</span>)
  <span class="keyword">if</span> existence_check <span class="keyword">isnt</span> <span class="string">""</span>
    <span class="keyword">if</span> last_accessor <span class="keyword">instanceof</span> Grammar.ExisentialCheck
      rv = <span class="string">"(<span class="subst">#{existence_check}</span>)"</span>
    <span class="keyword">else</span>
      closeout = <span class="string">"void 0"</span>
      rv = <span class="string">"((<span class="subst">#{existence_check}</span>) ? <span class="subst">#{rv}</span> : <span class="subst">#{closeout}</span>)"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <p>Lastly, prefix operators are prepended to the output code. These include <code>new</code>, <code>typeof</code>, <code>-</code>, <code>not</code>, and <code>bitwise not</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  preop_value = me.preop?.<span class="keyword">value</span>
  <span class="keyword">if</span> preop_value <span class="keyword">is</span> <span class="string">'new'</span> <span class="keyword">or</span> preop_value <span class="keyword">is</span> <span class="string">'typeof'</span>
    rv = <span class="string">"<span class="subst">#{KEYWORD_TRANSLATE[preop_value]}</span> <span class="subst">#{rv}</span>"</span>
  <span class="keyword">else</span> <span class="keyword">if</span> preop_value <span class="keyword">is</span> <span class="string">'not'</span>
    preop_value = <span class="string">"bitwise not"</span> <span class="keyword">if</span> me.<span class="keyword">bitwise</span>
    rv = <span class="string">"<span class="subst">#{KEYWORD_TRANSLATE[preop_value]}</span>(<span class="subst">#{rv}</span>)"</span>
  <span class="keyword">else</span> <span class="keyword">if</span> preop_value <span class="keyword">is</span> <span class="string">'-'</span>
    rv = <span class="string">"-<span class="subst">#{rv}</span>"</span>
  <span class="keyword">return</span> rv</pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <h3>WhenExpression</h3>
<p><code>WhenExpression</code>s are tail conditionals. When calling this method, we pass in the JavaScript that returns the “true” value (<code>true_block_js</code>).</p>
<p>We also pass in the JavaScript that returns the “false” value (<code>false_js</code>) if there is any, for example when we do <code>1 if x otherwise 2</code>. <code>must_return_value</code> is set to true if this expression needs to have a return value and can&#39;t be turned into an <code>if</code> statement, for example in assignment (<code>x = 1 if x else 2</code>), the right-hand side needs to return a value and can&#39;t be turned into an <code>if</code> statement.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">(true_block_js, must_return_value, false_js)</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">WhenExpression</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <p>Compile the conditional expression.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  conditional_js = me.condition.js()</pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <p>Invert if necessary based on the specifier.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> me.specifier.<span class="keyword">value</span> <span class="keyword">is</span> <span class="string">'unless'</span> <span class="keyword">or</span> me.specifier.<span class="keyword">value</span> <span class="keyword">is</span> <span class="string">'except'</span>
    conditional_js = <span class="string">"!(<span class="subst">#{conditional_js}</span>)"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <p>If we have a false branch parsed as part of this expression, we return a ternary with the compiled version of that expression.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> me.false_expr <span class="keyword">exists</span> <span class="keyword">and</span> false_js <span class="keyword">doesnt</span> <span class="keyword">exist</span>
    <span class="keyword">return</span> <span class="string">"(<span class="subst">#{conditional_js}</span>) ? <span class="subst">#{true_block_js}</span> : <span class="subst">#{me.false_expr.js()}</span>"</span>
  <span class="keyword">else</span></pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <p>If we need a return value, we use a ternary that returns undefined for false.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> must_return_value
      <span class="keyword">return</span> <span class="string">"(<span class="subst">#{conditional_js}</span>) ? <span class="subst">#{true_block_js}</span> : void 0"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <p>Otherwise this becomes an if statement for things like <code>return x if x exists</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">else</span>
      rv = <span class="string">"if (<span class="subst">#{conditional_js}</span>) {\n<span class="subst">#{indent(true_block_js)}</span>}"</span>
      rv += <span class="string">" else {\n<span class="subst">#{false_js}</span>}"</span> <span class="keyword">if</span> false_js <span class="keyword">exists</span>
      rv += <span class="string">"\n"</span>
      <span class="keyword">return</span> rv</pre></div></div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <h3>ExisentialCheck</h3>
<p>An existential check is used to check if a variable is non-null and defined. The <code>js</code> method is never called because these are only parsed as accessors for <code>UnaryExpression</code>s. <code>UnaryExpression</code> calls <code>js_existence</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">ExisentialCheck</span></span>
  <span class="keyword">return</span> <span class="string">""</span></pre></div></div>
            
        </li>
        
        
        <li id="section-91">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>
              <p>In this case we just use the <code>check_existence_wrapper</code> utility.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js_existence</span><span class="params">(accessor, undefined_unary, invert)</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">ExisentialCheck</span></span>
  <span class="keyword">return</span> check_existence_wrapper(accessor, undefined_unary, invert)</pre></div></div>
            
        </li>
        
        
        <li id="section-92">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-92">&#182;</a>
              </div>
              <h3>PropertyAccess</h3>
<p>For property access we just defer to JavaScript&#39;s built in <code>.</code> operator.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">PropertyAccess</span></span>
  <span class="keyword">if</span> me.expr.type <span class="keyword">is</span> <span class="string">'IDENTIFIER'</span>
    rv = me.expr.<span class="keyword">value</span>
  <span class="keyword">else</span>
    rv = me.expr.js()
  rv = <span class="string">".<span class="subst">#{rv}</span>"</span>
  <span class="keyword">return</span> rv</pre></div></div>
            
        </li>
        
        
        <li id="section-93">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-93">&#182;</a>
              </div>
              <p>If this access has an exisential qualifier (<code>a?.b</code>), we generate a wrapper.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js_existence</span><span class="params">(accessor, undefined_unary, invert)</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">PropertyAccess</span></span>
  <span class="keyword">if</span> me.exisential
    <span class="keyword">return</span> check_existence_wrapper(accessor, undefined_unary, invert)
  <span class="keyword">else</span>
    <span class="keyword">return</span> <span class="string">''</span></pre></div></div>
            
        </li>
        
        
        <li id="section-94">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-94">&#182;</a>
              </div>
              <h3>AssignmentStatement</h3>
<p>Assignment statements are not context dependent. Asynchronous assignments are done using <code>wait for</code>s.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">AssignmentStatement</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-95">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-95">&#182;</a>
              </div>
              <p>We need to set the <code>compound_assign</code> flag on our l-value if we are using a compound assignment like <code>+=</code>. This tells the l-value not to automatically declare itself. We do this because the l-value is accessed before assignment, so we want the JavaScript to throw an error if it hasn&#39;t been defined yet. For <code>=</code>, we do want the l-value to get declared if necessary.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  op = me.assignOp.<span class="keyword">value</span>
  <span class="keyword">if</span> op <span class="keyword">isnt</span> <span class="string">'='</span>
    op += <span class="string">'='</span>
    me.lvalue.compound_assign = <span class="literal">yes</span>
  rv = <span class="string">"<span class="subst">#{me.lvalue.js()}</span> <span class="subst">#{op}</span> <span class="subst">#{me.rvalue.js()}</span>;\n"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-96">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-96">&#182;</a>
              </div>
              <p>For prettyness, we add an extra newline after anonymous function definitions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  rv += <span class="string">'\n'</span> <span class="keyword">if</span> me.rvalue.left.base <span class="keyword">instanceof</span> Grammar.FunctionExpression</pre></div></div>
            
        </li>
        
        
        <li id="section-97">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-97">&#182;</a>
              </div>
              <p>The statement is wrapped with its tail conditional if there is one.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  rv = me.conditional.js(rv, <span class="literal">no</span>) <span class="keyword">if</span> me.conditional <span class="keyword">exists</span>
  <span class="keyword">return</span> rv</pre></div></div>
            
        </li>
        
        
        <li id="section-98">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-98">&#182;</a>
              </div>
              <h3>NumberConstant</h3>
<p>We actually use the raw token text here rather than the numeric value. JavaScript and Kal number syntax are identical, so no trascompiling is necessary. It also makes the JavaScript output more readable if we avoid converting things, especially for hex values.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">NumberConstant</span></span>
  <span class="keyword">return</span> me.token.text</pre></div></div>
            
        </li>
        
        
        <li id="section-99">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-99">&#182;</a>
              </div>
              <h3>StringConstant</h3>
<p>We pass through the string value (the part between quotes) here.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">StringConstant</span></span>
  <span class="keyword">return</span> me.token.<span class="keyword">value</span></pre></div></div>
            
        </li>
        
        
        <li id="section-100">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-100">&#182;</a>
              </div>
              <h3>RegexConstant</h3>
<p>Just let JavaScript handle the regex syntax.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">RegexConstant</span></span>
  <span class="keyword">return</span> me.token.text</pre></div></div>
            
        </li>
        
        
        <li id="section-101">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-101">&#182;</a>
              </div>
              <h3>BinOp</h3>
<p>Operators are compiled using the <code>KEYWORD_TRANSLATE</code> mapping.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">BinOp</span></span>
  op_value = me.op.<span class="keyword">value</span>
  op_value = <span class="string">"bitwise <span class="subst">#{op_value}</span>"</span> <span class="keyword">if</span> me.<span class="keyword">bitwise</span>
  <span class="keyword">return</span> KEYWORD_TRANSLATE[op_value] <span class="keyword">or</span> me.op.<span class="keyword">value</span></pre></div></div>
            
        </li>
        
        
        <li id="section-102">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-102">&#182;</a>
              </div>
              <h3>IfStatement</h3>
<p><code>IfStatement</code>s are context dependent. When the <code>js</code> method is called, we actually don&#39;t know if there will be asynchronous code inside the <code>if</code>/<code>else</code> blocks. We first try generating JavaScript assuming this is pure synchronous code using <code>js_no_callbacks</code>. If we detect asynchronous calls after code generation, we throw away those results and generate asynchronous code using <code>js_callbacks</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">IfStatement</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-103">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-103">&#182;</a>
              </div>
              <p>We record the original callback function name for two reasons. First, we want to be able to check if any new callbacks get generated when we generate our code blocks. This would indicate asynchronous code in the blocks. Second, all branches need to execute a callback to the original_callback once they are finished.</p>
<p><code>me.original_callback</code> can be set for us by a parent block if we previously hit asynchronous code.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  me.original_callback = me.callback <span class="keyword">unless</span> me.original_callback <span class="keyword">exists</span></pre></div></div>
            
        </li>
        
        
        <li id="section-104">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-104">&#182;</a>
              </div>
              <p>We store the <code>cb_counter</code> so that we can reset it if we decide to regenerate JavaScript.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  cb_counter = callback_counter</pre></div></div>
            
        </li>
        
        
        <li id="section-105">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-105">&#182;</a>
              </div>
              <p><code>conditional_js</code> stores the generated JavaScript for the conditional expression in the <code>if</code> statement.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  conditional_js = me.conditional.js()
  <span class="keyword">if</span> me.condition.<span class="keyword">value</span> <span class="keyword">is</span> <span class="string">'unless'</span> <span class="keyword">or</span> me.condition.<span class="keyword">value</span> <span class="keyword">is</span> <span class="string">'except'</span>
    conditional_js = <span class="string">"!(<span class="subst">#{conditional_js}</span>)"</span>
  rv = <span class="string">"if (<span class="subst">#{conditional_js}</span>) {\n"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-106">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-106">&#182;</a>
              </div>
              <p>We need to set the <code>in_conditional</code> flag (which propagates down) so that any child blocks know to call back to the <code>original_callback</code> when they complete. We pass the similar <code>in_loop</code> flag down.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  me.block.in_conditional = <span class="literal">yes</span>
  me.block.in_loop = me.in_loop
  <span class="keyword">for</span> else_clause <span class="keyword">in</span> me.elses
    else_clause.block.in_conditional = <span class="literal">yes</span>
    else_clause.block.in_loop = me.in_loop</pre></div></div>
            
        </li>
        
        
        <li id="section-107">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-107">&#182;</a>
              </div>
              <p>Try to make synchronous code.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  inner_js = me.js_no_callbacks()</pre></div></div>
            
        </li>
        
        
        <li id="section-108">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-108">&#182;</a>
              </div>
              <p>If there were asynchronous statements, try again with asynchronous code. We don&#39;t bother in <code>else if</code>s because our parent <code>if</code> will do this for us.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> me.callback <span class="keyword">isnt</span> current_callback but <span class="keyword">not</span> me.is_else_if
    callback_counter = cb_counter
    inner_js = me.js_callbacks()
  <span class="keyword">return</span> rv + inner_js</pre></div></div>
            
        </li>
        
        
        <li id="section-109">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-109">&#182;</a>
              </div>
              <p><code>js_no_callbacks</code> generates synchronous code.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js_no_callbacks</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">IfStatement</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-110">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-110">&#182;</a>
              </div>
              <p>Pass any parent block callback, if one exists, down the tree.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  me.block.callback = me.callback</pre></div></div>
            
        </li>
        
        
        <li id="section-111">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-111">&#182;</a>
              </div>
              <p>Compile and indent the block.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  block_js = indent(me.block.js() + me.block.js_closeout()) + <span class="string">'}'</span>
  block_js += <span class="string">'\n'</span> <span class="keyword">if</span> me.<span class="keyword">else</span>s.length <span class="keyword">is</span> <span class="number">0</span>
  else_js = <span class="string">""</span></pre></div></div>
            
        </li>
        
        
        <li id="section-112">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-112">&#182;</a>
              </div>
              <p>Compile any <code>else</code> or <code>else if</code> clauses.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">for</span> else_clause <span class="keyword">in</span> me.elses
    else_clause.block.callback = me.callback
    else_clause.block.original_callback = me.original_callback
    else_js += <span class="string">" else"</span>
    <span class="keyword">if</span> else_clause.conditional <span class="keyword">exists</span>
      else_js += <span class="string">" if (<span class="subst">#{else_clause.conditional.js()}</span>)"</span>
    else_js += <span class="string">" {\n"</span>
    else_js += indent(else_clause.block.js() + else_clause.block.js_closeout())
    else_js += <span class="string">'}\n'</span>
  <span class="keyword">return</span> block_js + else_js</pre></div></div>
            
        </li>
        
        
        <li id="section-113">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-113">&#182;</a>
              </div>
              <p><code>js_callbacks</code> generates asynchronous code.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js_callbacks</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">IfStatement</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-114">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-114">&#182;</a>
              </div>
              <p>We need a callback that branches use to exit. All branches must call this callback whether they are synchronous or asynchronous. This callback gets passed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  me.callback = create_callback()
  me.block.callback = me.callback
  me.block.original_callback = me.callback</pre></div></div>
            
        </li>
        
        
        <li id="section-115">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-115">&#182;</a>
              </div>
              <p>Compile the block and any <code>else</code>s or <code>else if</code>s.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  block_js = indent me.block.js()
  <span class="keyword">for</span> else_clause <span class="keyword">in</span> me.elses</pre></div></div>
            
        </li>
        
        
        <li id="section-116">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-116">&#182;</a>
              </div>
              <p>We pass callback trackers down the tree.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    else_clause.block.callback = me.callback
    else_clause.block.original_callback = me.callback
    else_clause.block_js_header = <span class="string">" else "</span>
    <span class="keyword">if</span> else_clause.conditional <span class="keyword">exists</span>
      else_clause.block_js_header += <span class="string">"if (<span class="subst">#{else_clause.conditional.js()}</span>) "</span>
    else_clause.block_js_header += <span class="string">"{\n"</span>
    else_clause.block_js = indent else_clause.block.js()
  block_js += indent(me.block.js_closeout()) + <span class="string">'}'</span>
  block_js += <span class="string">'\n'</span> <span class="keyword">if</span> me.<span class="keyword">else</span>s.length <span class="keyword">is</span> <span class="number">0</span>
  else_js = <span class="string">""</span></pre></div></div>
            
        </li>
        
        
        <li id="section-117">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-117">&#182;</a>
              </div>
              <p>We construct the JavaScript output using the headers we made above, the block JavaScript, and by calling <code>js_closeout</code> to get any callback headers and exit callbacks.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">for</span> else_clause <span class="keyword">in</span> me.elses
    else_js += else_clause.block_js_header + else_clause.block_js + indent(else_clause.block.js_closeout()) + <span class="string">'}'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-118">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-118">&#182;</a>
              </div>
              <p>Make sure we include the <code>async</code> snippet since we&#39;re about to use it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  use_snippets[<span class="string">'async'</span>] = snippets[<span class="string">'async'</span>]</pre></div></div>
            
        </li>
        
        
        <li id="section-119">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-119">&#182;</a>
              </div>
              <p>We wrap any code after this <code>if</code> statement in our callback function. We also add a call to this function in case we get out of the <code>if</code> statement synchronously.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  callback_js = <span class="string">"return k$async(<span class="subst">#{me.callback}</span>,<span class="subst">#{kthis()}</span>);\n"</span>
  callback_js += <span class="string">"function <span class="subst">#{me.callback}</span>() {\n"</span>
  callback_js += indent render_try_blocks()</pre></div></div>
            
        </li>
        
        
        <li id="section-120">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-120">&#182;</a>
              </div>
              <p>Tell our parent block what function it is shoving code into.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  me.parent_block.closeout_callback = me.original_callback</pre></div></div>
            
        </li>
        
        
        <li id="section-121">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-121">&#182;</a>
              </div>
              <p>Generate a new callback for future if statements/for loops</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  create_callback()
  <span class="keyword">return</span> block_js + else_js + <span class="string">'\n'</span> + callback_js</pre></div></div>
            
        </li>
        
        
        <li id="section-122">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-122">&#182;</a>
              </div>
              <h3>BlankStatement</h3>
<p>The simplest statement, and the most important. The most important line of code is the one you didn&#39;t write. Except in Kal, where <code>pass</code> is required to make an empty block.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">BlankStatement</span></span>
  <span class="keyword">return</span> <span class="string">''</span></pre></div></div>
            
        </li>
        
        
        <li id="section-123">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-123">&#182;</a>
              </div>
              <h3>ForStatement</h3>
<p><code>ForStatement</code>s are context dependent. When the <code>js</code> method is called, we actually don&#39;t know if there will be asynchronous code inside the loop block. We first try generating JavaScript assuming this is pure synchronous code using <code>js_no_callbacks</code>. If we detect asynchronous calls after code generation, we throw away those results and generate asynchronous code using <code>js_callbacks</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">ForStatement</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-124">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-124">&#182;</a>
              </div>
              <p>Save the current callback name. We use this to check if any asynchronous code got generated from our block.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  me.callback = current_callback</pre></div></div>
            
        </li>
        
        
        <li id="section-125">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-125">&#182;</a>
              </div>
              <p>Pass the <code>in_loop</code> and <code>in_conditional</code> variables down the tree. These are used in block closouts to decide if we need to call a callback.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  me.loop_block.in_loop = <span class="literal">yes</span>
  me.loop_block.in_conditional = me.in_conditional</pre></div></div>
            
        </li>
        
        
        <li id="section-126">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-126">&#182;</a>
              </div>
              <p>Generate variables for an iterator, terminator (end of loop check), and a loop counter (used for asynchronous calls to count the number of callbacks required).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  rv = <span class="string">""</span>
  iterator   = <span class="string">"ki$<span class="subst">#{for_count}</span>"</span>
  terminator = <span class="string">"kobj$<span class="subst">#{for_count}</span>"</span>
  loop_counter = <span class="string">"klc$<span class="subst">#{for_count}</span>"</span>
  for_count += <span class="number">1</span></pre></div></div>
            
        </li>
        
        
        <li id="section-127">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-127">&#182;</a>
              </div>
              <p>Declare the iterant variable (the <code>x</code> from <code>for x in y</code>).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  scope[me.iterant.<span class="keyword">value</span>] = <span class="string">'closures ok'</span> <span class="keyword">unless</span> scope[me.iterant.<span class="keyword">value</span>] <span class="keyword">exists</span></pre></div></div>
            
        </li>
        
        
        <li id="section-128">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-128">&#182;</a>
              </div>
              <p>Try generating synchronous code, fall back to asynchronous code if we detect something asynchronous in our block.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  loop_block_js = me.loop_block.js() + me.loop_block.js_closeout()
  <span class="keyword">if</span> me.callback <span class="keyword">isnt</span> current_callback
    <span class="keyword">return</span> me.js_callbacks iterator, terminator, loop_counter
  <span class="keyword">else</span></pre></div></div>
            
        </li>
        
        
        <li id="section-129">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-129">&#182;</a>
              </div>
              <p>Declare the iterator and terminator.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    scope[iterator] = <span class="string">'no closures'</span>
    scope[terminator] = <span class="string">'no closures'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-130">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-130">&#182;</a>
              </div>
              <p><code>for ... in ...</code> loops just loop from element 0 of the iterable (the <code>y</code> in <code>for x in y</code>) to element <code>iterable.length - 1</code>. We assign the element to the user supplied <code>iterant</code> (<code>x</code>) at  the beginning of each iteration.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> me.type.<span class="keyword">value</span> <span class="keyword">is</span> <span class="string">'in'</span>
      rv += <span class="string">"<span class="subst">#{terminator}</span> = <span class="subst">#{me.iterable.js()}</span>;\n"</span>
      rv += <span class="string">"for (<span class="subst">#{iterator}</span> = 0; <span class="subst">#{iterator}</span> &lt; <span class="subst">#{terminator}</span>.length; <span class="subst">#{iterator}</span>++) {\n"</span>
      rv += <span class="string">"  <span class="subst">#{me.iterant.<span class="keyword">value</span>}</span> = <span class="subst">#{terminator}</span>[<span class="subst">#{iterator}</span>];\n"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-131">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-131">&#182;</a>
              </div>
              <p><code>for ... of ...</code> loops loop through each property of the iterable (the <code>y</code> in <code>for x of y</code>) in whatever order. Luckily the JavaScript <code>in</code> operator does almost exactly this. We do have to skip properties that don&#39;t meet the <code>hasOwnProperty</code> criterion since these are inherited. We assign the element to the user supplied <code>iterant</code> (<code>x</code>) at the beginning of each iteration.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">else</span>
      rv += <span class="string">"<span class="subst">#{terminator}</span> = <span class="subst">#{me.iterable.js()}</span>;\n"</span>
      rv += <span class="string">"for (<span class="subst">#{me.iterant.<span class="keyword">value</span>}</span> in <span class="subst">#{terminator}</span>) {\n"</span>
      rv += <span class="string">"  if (!<span class="subst">#{terminator}</span>.hasOwnProperty(<span class="subst">#{me.iterant.<span class="keyword">value</span>}</span>)) {continue;}\n"</span>
    rv += indent loop_block_js
    rv += <span class="string">"}\n"</span>
  <span class="keyword">return</span> rv</pre></div></div>
            
        </li>
        
        
        <li id="section-132">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-132">&#182;</a>
              </div>
              <p><code>js_callbacks</code> generates asynchronous code for parallel and series <code>for</code> loops.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js_callbacks</span><span class="params">(iterator, terminator, loop_counter)</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">ForStatement</span></span>
  rv = <span class="string">""</span></pre></div></div>
            
        </li>
        
        
        <li id="section-133">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-133">&#182;</a>
              </div>
              <p>The <code>execution_style</code> actually matters for asynchronous loops. The default, if none is specified, is <code>series</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> me.execution_style?.<span class="keyword">value</span> <span class="keyword">is</span> <span class="string">'parallel'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-134">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-134">&#182;</a>
              </div>
              <p>The <code>loop_callback</code> is called after each iteration of the loop. It uses <code>loop_counter</code> to detect when all iterations have called back. <code>callback</code> is used after <code>loop_callback</code> decides the loop is done.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    loop_callback = create_callback()
    me.callback = create_callback()</pre></div></div>
            
        </li>
        
        
        <li id="section-135">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-135">&#182;</a>
              </div>
              <p>Pass the loop callback down the tree.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    me.loop_block.callback = loop_callback
    me.loop_block.original_callback = loop_callback</pre></div></div>
            
        </li>
        
        
        <li id="section-136">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-136">&#182;</a>
              </div>
              <p>We do need a special stack for parallel for loop callbacks so that <code>catch</code> blocks know where to call back to.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    parfor_cb_stack.push parfor_cb
    parfor_cb = loop_callback</pre></div></div>
            
        </li>
        
        
        <li id="section-137">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-137">&#182;</a>
              </div>
              <p>Declare the iterator and terminator.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    scope[iterator] = <span class="string">'no closures'</span>
    scope[terminator] = <span class="string">'no closures'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-138">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-138">&#182;</a>
              </div>
              <p>We wrap the loop block in a function because we want a unique scope for each call to the loop body. Otherwise, you could wind up with the following situation:</p>
<p><pre>
for parallel x in y
  wait for update(x)
  wait for save(x)
</pre>
If x was part of the current scope, it could change between the <code>wait for</code>s if another iteration of the loop was executing. By making <code>x</code> an argument to a function, it creates a unique scope for each loop iteration.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rv += <span class="string">"(function (<span class="subst">#{loop_counter}</span>) {\n"</span>
    rv += <span class="string">"  <span class="subst">#{terminator}</span> = <span class="subst">#{me.iterable.js()}</span>;\n"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-139">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-139">&#182;</a>
              </div>
              <p>Handle <code>in</code> and <code>of</code> operators like we do in synchronous loops.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> me.type.<span class="keyword">value</span> <span class="keyword">is</span> <span class="string">'in'</span>
      rv += <span class="string">"  for (<span class="subst">#{iterator}</span> = 0; <span class="subst">#{iterator}</span> &lt; <span class="subst">#{terminator}</span>.length; <span class="subst">#{iterator}</span>++) {\n"</span>
    <span class="keyword">else</span>
      rv += <span class="string">"  for (<span class="subst">#{iterator}</span> in <span class="subst">#{terminator}</span>) {\n"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-140">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-140">&#182;</a>
              </div>
              <p>Increment the number of calls back we are expecting.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rv += <span class="string">"      <span class="subst">#{loop_counter}</span>++;\n"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-141">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-141">&#182;</a>
              </div>
              <p>Async call a wrapper function for the loop block. This way all iterations start on the next tick.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rv += <span class="string">"      k$async(function (<span class="subst">#{me.iterant.<span class="keyword">value</span>}</span>) {\n"</span>
    rv += multi_indent(render_try_blocks(), <span class="number">3</span>)
    rv += multi_indent(me.loop_block.js() + me.loop_block.js_closeout(), <span class="number">3</span>)
    rv += multi_indent(render_catch_blocks(), <span class="number">3</span>)
    <span class="keyword">if</span> me.type.<span class="keyword">value</span> <span class="keyword">is</span> <span class="string">'in'</span>
      rv += <span class="string">"    },<span class="subst">#{kthis()}</span>,[<span class="subst">#{terminator}</span>[<span class="subst">#{iterator}</span>]]);\n"</span>
    <span class="keyword">else</span>
      rv += <span class="string">"    },<span class="subst">#{kthis()}</span>,[<span class="subst">#{iterator}</span>]);\n"</span>
    rv += <span class="string">"  }\n"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-142">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-142">&#182;</a>
              </div>
              <p>Ensure the async snippet is present.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    use_snippets[<span class="string">'async'</span>] = snippets[<span class="string">'async'</span>]</pre></div></div>
            
        </li>
        
        
        <li id="section-143">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-143">&#182;</a>
              </div>
              <p>Call back to the loop callback once all iterations are accounted for. This decrements the initial seed of 1 that we gave to the loop counter and ensures that the loop counter doesn&#39;t hit zero until all the iterations are at least started.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rv += <span class="string">"  return <span class="subst">#{loop_callback}</span>.apply(<span class="subst">#{kthis()}</span>);\n"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-144">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-144">&#182;</a>
              </div>
              <p>Once the loop counter is zero, the loop callback calls the actual callback.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rv += <span class="string">"  function <span class="subst">#{loop_callback}</span>() {\n"</span>
    rv += <span class="string">"    if (--<span class="subst">#{loop_counter}</span> == 0) return k$async(<span class="subst">#{me.callback}</span>,<span class="subst">#{kthis()}</span>);\n"</span>
    rv += <span class="string">"  }\n"</span>
    rv += <span class="string">"})(1);\n"</span>
    rv += <span class="string">"return;\n"</span>
    rv += <span class="string">"function <span class="subst">#{me.callback}</span>() {\n"</span>
    rv += indent render_try_blocks()
    me.parent_block.closeout_callback = me.original_callback
    parfor_cb = parfor_cb_stack.pop()</pre></div></div>
            
        </li>
        
        
        <li id="section-145">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-145">&#182;</a>
              </div>
              <p>Series for loops are the default.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">else</span></pre></div></div>
            
        </li>
        
        
        <li id="section-146">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-146">&#182;</a>
              </div>
              <p>Create the callback for the end of the loop. We can safely use <code>k$lcb</code> as the loop callback here since we using it inside a new function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    me.callback = create_callback()
    me.loop_block.callback = <span class="string">"k$lcb"</span>
    me.loop_block.original_callback = <span class="string">"k$lcb"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-147">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-147">&#182;</a>
              </div>
              <p>Make sure we have the async snippet.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    use_snippets[<span class="string">'async'</span>] = snippets[<span class="string">'async'</span>]</pre></div></div>
            
        </li>
        
        
        <li id="section-148">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-148">&#182;</a>
              </div>
              <p>For <code>for series ... in ...</code> loops, we call the <code>loop_counter</code> function with the index 0, our iterable, and the value of the iterant to kick off the loop.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> me.type.<span class="keyword">value</span> <span class="keyword">is</span> <span class="string">'in'</span>
      rv += <span class="string">"return k$async(<span class="subst">#{loop_counter}</span>,<span class="subst">#{kthis()}</span>,[0,<span class="subst">#{me.iterable.js()}</span>,<span class="subst">#{me.iterable.js()}</span>[0]]);\n"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-149">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-149">&#182;</a>
              </div>
              <p>For <code>for series ... of ...</code> loops, we fill in <code>terminator</code> with an array of <code>iterable</code>&#39;s  properties, then kick off <code>loop_counter</code> with an index 0, the array of properties, and the first element.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">else</span>
      scope[terminator] = <span class="string">'no closures'</span>
      scope[iterator] = <span class="string">'no closures'</span>
      rv += <span class="string">"<span class="subst">#{terminator}</span> = [];\n"</span>
      rv += <span class="string">"for (<span class="subst">#{iterator}</span> in <span class="subst">#{me.iterable.js()}</span>) {if ((<span class="subst">#{me.iterable.js()}</span>).hasOwnProperty(<span class="subst">#{iterator}</span>)) {<span class="subst">#{terminator}</span>.push(<span class="subst">#{iterator}</span>)};}\n"</span>
      rv += <span class="string">"return <span class="subst">#{loop_counter}</span>.apply(<span class="subst">#{kthis()}</span>,[0,<span class="subst">#{terminator}</span>,<span class="subst">#{terminator}</span>[0]]);\n"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-150">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-150">&#182;</a>
              </div>
              <p>The loop counter function first checks if the index variable is greater than the terminator length - 1. If so we are done looping and can execute the callback. Otherwise, we execute the loop block and queue up another call to <code>loop_counter</code>. We render <code>try</code>/<code>catch</code> blocks inside loop couner and our callback. function to make sure they get carried through.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rv += <span class="string">"function <span class="subst">#{loop_counter}</span>(k$i,k$obj,<span class="subst">#{me.iterant.<span class="keyword">value</span>}</span>) {\n"</span>
    rv += render_try_blocks()
    rv += <span class="string">"  k$i++;\n"</span>
    rv += <span class="string">"  var k$lcb = function () {if (k$i &lt; k$obj.length) return <span class="subst">#{loop_counter}</span>.apply(<span class="subst">#{kthis()}</span>,[k$i,k$obj,k$obj[k$i]]); else return k$async(<span class="subst">#{me.callback}</span>,<span class="subst">#{kthis()}</span>);};\n"</span>
    rv += indent(me.loop_block.js() + me.loop_block.js_closeout())
    rv += indent render_catch_blocks()
    rv += <span class="string">"}\n"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-151">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-151">&#182;</a>
              </div>
              <p>Our callback function, which we pass up to the parent block.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rv += <span class="string">"function <span class="subst">#{me.callback}</span>() {\n"</span>
    rv += indent render_try_blocks()
    me.parent_block.closeout_callback = me.original_callback
  <span class="keyword">return</span> rv</pre></div></div>
            
        </li>
        
        
        <li id="section-152">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-152">&#182;</a>
              </div>
              <h3>WhileStatement</h3>
<p><code>WhileStatement</code>s are context dependent. When the <code>js</code> method is called, we actually don&#39;t know if there will be asynchronous code inside the loop block. We first try generating JavaScript assuming this is pure synchronous code using <code>js</code>. If we detect asynchronous calls after code generation, we throw away those results and generate asynchronous code using <code>js_callbacks</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">WhileStatement</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-153">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-153">&#182;</a>
              </div>
              <p>Mark the loop and conditional flags for our child block.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  me.block.in_loop = <span class="literal">yes</span>
  me.block.in_conditional = me.in_conditional</pre></div></div>
            
        </li>
        
        
        <li id="section-154">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-154">&#182;</a>
              </div>
              <p><code>until</code> is the same as <code>while</code> except that we invert the conditional.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> me.specifier.<span class="keyword">value</span> <span class="keyword">is</span> <span class="string">'until'</span>
    rv = <span class="string">"while (!(<span class="subst">#{me.expr.js()}</span>)) {\n"</span>
  <span class="keyword">else</span>
    rv = <span class="string">"while (<span class="subst">#{me.expr.js()}</span>) {\n"</span>
  rv += indent(me.block.js() + me.block.js_closeout())
  rv += <span class="string">"}\n"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-155">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-155">&#182;</a>
              </div>
              <p>If asynchronous code was detected, we throw away <code>rv</code> and generate an async while loop.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> me.callback <span class="keyword">isnt</span> current_callback
    <span class="keyword">return</span> me.js_callbacks()
  <span class="keyword">else</span>
    <span class="keyword">return</span> rv<span class="function">

<span class="keyword">method</span> <span class="title">js_callbacks</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">WhileStatement</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-156">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-156">&#182;</a>
              </div>
              <p>Asynchronous while loops do actually need a loop counter and a callback for when the loop is finished. We also need a loop callback that runs after each iteration.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  rv = <span class="string">""</span>
  while_count += <span class="number">1</span>
  while_wrapper = <span class="string">"kw$<span class="subst">#{while_count}</span>"</span>
  me.callback = create_callback()
  me.block.callback = <span class="string">"k$lcb"</span>
  me.block.original_callback = <span class="string">"k$lcb"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-157">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-157">&#182;</a>
              </div>
              <p>Make sure to include the async snippet.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  use_snippets[<span class="string">'async'</span>] = snippets[<span class="string">'async'</span>]</pre></div></div>
            
        </li>
        
        
        <li id="section-158">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-158">&#182;</a>
              </div>
              <p>We wrap the code block in a function that runs for each iteration.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  rv += <span class="string">"return <span class="subst">#{while_wrapper}</span>();\n"</span>
  rv += <span class="string">"function <span class="subst">#{while_wrapper}</span>() {\n"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-159">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-159">&#182;</a>
              </div>
              <p><code>try</code> and <code>catch</code> blocks need to be reinserted in the new function context.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  rv += render_try_blocks()</pre></div></div>
            
        </li>
        
        
        <li id="section-160">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-160">&#182;</a>
              </div>
              <p>We finish the iteration by calling back to <code>k$lcb</code> and checking the conditional (or it&#39;s inverse if appropriate). If the check passes we do an async call to <code>while_wrapper</code> again. This puts it on the next tick to avoid super-deep recursion depth.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  expr_js = me.expr.js()
  expr_js = <span class="string">"!(<span class="subst">#{expr_js}</span>)"</span> <span class="keyword">when</span> me.specifier.<span class="keyword">value</span> <span class="keyword">is</span> <span class="string">'until'</span>
  rv += <span class="string">"  var k$lcb = function () {if (<span class="subst">#{expr_js}</span>) return <span class="subst">#{while_wrapper}</span>.apply(<span class="subst">#{kthis()}</span>); else return k$async(<span class="subst">#{me.callback}</span>,<span class="subst">#{kthis()}</span>);};\n"</span>
  rv += indent(me.block.js() + me.block.js_closeout())
  rv += indent(render_catch_blocks())
  rv += <span class="string">"}\n"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-161">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-161">&#182;</a>
              </div>
              <p>Code after this loop is wrapped with a callback wrapper and we re-render try blocks. We tell our parent block what callback it is writing code to.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  rv += <span class="string">"function <span class="subst">#{me.callback}</span>() {\n"</span>
  rv += indent render_try_blocks()
  me.parent_block.closeout_callback = me.original_callback
  <span class="keyword">return</span> rv</pre></div></div>
            
        </li>
        
        
        <li id="section-162">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-162">&#182;</a>
              </div>
              <h3>LoopControlStatement</h3>
<p>This is a very simple class to allow us to use the <code>break</code> and <code>continue</code> keywords.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">LoopControlStatement</span></span>
  <span class="keyword">return</span> <span class="string">"<span class="subst">#{me.control.<span class="keyword">value</span>}</span>;\n"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-163">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-163">&#182;</a>
              </div>
              <h3>Block</h3>
<p><code>Block</code>s can be standard blocks, like in an <code>if</code> statement, or a derived class, like <code>BlockWithoutIndent</code>. A <code>Block</code> is an ordered list of statements. The <code>js</code> function generates JavaScript for the block&#39;s statements. The <code>js_closeout</code> function closes out any lingering callback functions and <code>catch</code> blocks in case one of the block&#39;s statements inserted a callback function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">Block</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-164">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-164">&#182;</a>
              </div>
              <p>We set the callback to the current one unless a parent node has already specified a callback to use. We save this callback to check later if any asynchronous code was generated.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  me.callback = current_callback <span class="keyword">unless</span> me.callback <span class="keyword">exists</span>
  me.original_callback = current_callback <span class="keyword">unless</span> me.original_callback <span class="keyword">exists</span>
  previous_cb = current_callback</pre></div></div>
            
        </li>
        
        
        <li id="section-165">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-165">&#182;</a>
              </div>
              <p><code>callbacks</code> is a list of callbacks we need to close out (add a trailing <code>}</code> to <code>catch</code> blocks) in <code>js_closeout</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  me.callbacks = []
  rv = <span class="string">''</span>
  me.indent_level = <span class="number">0</span></pre></div></div>
            
        </li>
        
        
        <li id="section-166">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-166">&#182;</a>
              </div>
              <p>We compile each statement and pass through callback information along with conditional and loop flags.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">for</span> statement <span class="keyword">in</span> me.statements
    statement.parent_block = <span class="literal">me</span>
    statement.callback = me.callback
    statement.original_callback = me.original_callback
    statement.in_conditional = me.in_conditional
    statement.in_loop = me.in_loop
    statement_js = statement.js()</pre></div></div>
            
        </li>
        
        
        <li id="section-167">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-167">&#182;</a>
              </div>
              <p>Code is indented to look pretty, trying to avoid multiple newlines.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> statement_js[<span class="number">0</span>] <span class="keyword">is</span> <span class="string">'\n'</span> <span class="keyword">and</span> (rv.slice(-<span class="number">2</span>) <span class="keyword">is</span> <span class="string">'\n\n'</span> <span class="keyword">or</span> rv.length <span class="keyword">is</span> <span class="number">0</span>)
      rv += multi_indent statement_js.slice(<span class="number">1</span>), me.indent_level
    <span class="keyword">else</span>
      rv += multi_indent statement_js, me.indent_level</pre></div></div>
            
        </li>
        
        
        <li id="section-168">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-168">&#182;</a>
              </div>
              <p>We need to indent if this statement started a new callback function. We also save the new callback.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> current_callback <span class="keyword">isnt</span> previous_cb
      me.indent_level += <span class="number">1</span>
      me.callbacks.unshift me.callback
      me.callback = current_callback
      previous_cb = current_callback</pre></div></div>
            
        </li>
        
        
        <li id="section-169">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-169">&#182;</a>
              </div>
              <p>If there is any asynchronous code, we need to handle the case where we have an implied <code>return</code> (the function ends without an explicit <code>return</code> statement). If code execution gets to the end of the function or task, we check for a <code>k$next</code> variable and call back to it. We clear out <code>k$next</code> before doing this to avoid ever calling back twice.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> me.callbacks.length &gt; <span class="number">0</span>
    <span class="keyword">if</span> scope[<span class="string">'k$next'</span>] <span class="keyword">exists</span>
      rv += multi_indent <span class="string">"var k$done = (typeof k$next == 'function') ? k$next : function () {}; k$next=function () {}; return k$done();\n"</span>, me.indent_level + <span class="number">1</span>
  <span class="keyword">return</span> rv</pre></div></div>
            
        </li>
        
        
        <li id="section-170">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-170">&#182;</a>
              </div>
              <p>The closeout method calls the block&#39;s <code>closeout_callback</code> if it exists. This ensures all branches of <code>if</code> statements call back to the <code>if</code> block&#39;s callback.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js_closeout</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">Block</span></span>
  rv = <span class="string">""</span>
  <span class="keyword">if</span> me.closeout_callback <span class="keyword">exists</span> <span class="keyword">and</span> me.callbacks.length <span class="keyword">isnt</span> <span class="number">0</span> <span class="keyword">and</span> (me.in_conditional <span class="keyword">or</span> me.in_loop)
    use_snippets[<span class="string">'async'</span>] = snippets[<span class="string">'async'</span>]
    rv += multi_indent <span class="string">"return k$async(<span class="subst">#{me.closeout_callback}</span>,<span class="subst">#{kthis()}</span>);\n"</span>, me.indent_level</pre></div></div>
            
        </li>
        
        
        <li id="section-171">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-171">&#182;</a>
              </div>
              <p>We also rerender any <code>catch</code> blocks at the end of each callback function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">for</span> callback <span class="keyword">in</span> me.callbacks
    rv += multi_indent render_catch_blocks(), me.indent_level
    rv += multi_indent <span class="string">"}\n"</span>, me.indent_level - <span class="number">1</span>
  <span class="keyword">return</span> rv</pre></div></div>
            
        </li>
        
        
        <li id="section-172">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-172">&#182;</a>
              </div>
              <h3>ParenExpression</h3>
<p>A <code>ParenExpression</code> is just a normal expression surrounded by parentheses.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">ParenExpression</span></span>
  <span class="keyword">return</span> <span class="string">"(<span class="subst">#{me.expr.js()}</span>)"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-173">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-173">&#182;</a>
              </div>
              <h3>IndexExpression</h3>
<p>An <code>IndexExpression</code> is an accessor for accessing an array index or object property. It works the same as JavaScript&#39;s <code>[]</code> operator so we just pass it through.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">IndexExpression</span></span>
  <span class="keyword">return</span> <span class="string">"[<span class="subst">#{me.expr.js()}</span>]"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-174">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-174">&#182;</a>
              </div>
              <p>As an accessor, it can have an exisential check like <code>a?[1]</code>, so we support the <code>js_existence</code> method. This method just passes the arguments to <code>check_existence_wrapper</code> if the <code>IndexExpression</code> has an exisential chcek.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js_existence</span><span class="params">(accessor, undefined_unary, invert)</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">IndexExpression</span></span>
  <span class="keyword">if</span> me.exisential
    <span class="keyword">return</span> check_existence_wrapper(accessor, undefined_unary, invert)
  <span class="keyword">else</span>
    <span class="keyword">return</span> <span class="string">''</span></pre></div></div>
            
        </li>
        
        
        <li id="section-175">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-175">&#182;</a>
              </div>
              <h3>ListExpression</h3>
<p>A <code>ListExpression</code> is a definition of a list like <code>[1, a, 2+3]</code>. We just pass this through to JavaScript.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">ListExpression</span></span>
  <span class="keyword">if</span> me.comprehension <span class="keyword">doesnt</span> <span class="keyword">exist</span>
    rv = []
    <span class="keyword">for</span> item <span class="keyword">in</span> me.items
      rv.push item.js()
    rv = rv.join(<span class="string">', '</span>)
    <span class="keyword">return</span> <span class="string">"[<span class="subst">#{rv}</span>]"</span>
  <span class="keyword">else</span>
    <span class="keyword">return</span> me.comprehension.js()</pre></div></div>
            
        </li>
        
        
        <li id="section-176">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-176">&#182;</a>
              </div>
              <h3>ListComprehension</h3>
<p>List comprehensions support the <code>[x*x for x in [1,2,3]]</code> syntax. We just use the <code>k$comprl</code> function (“array list comprehension” snippet) for this. We pass this snippet the iterable and a function to perform on each item.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">ListComprehension</span></span>
  use_snippets[<span class="string">'array list comprehension'</span>] = snippets[<span class="string">'array list comprehension'</span>]
  scope[me.iterant.<span class="keyword">value</span>] = <span class="string">'closures ok'</span>
  rv = <span class="string">"k$comprl(<span class="subst">#{me.iterable.js()}</span>,function (k$i) {<span class="subst">#{me.iterant.<span class="keyword">value</span>}</span> = k$i; return <span class="subst">#{me.iter_expr.js()}</span>;})"</span>
  <span class="keyword">return</span> rv</pre></div></div>
            
        </li>
        
        
        <li id="section-177">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-177">&#182;</a>
              </div>
              <h3>ObjectComprehension</h3>
<p>Object comprehensions support the <code>[x*x for x of {a:1,b:2}]</code> syntax and the <code>property</code>/<code>value</code> keywords. We just use the <code>k$compro</code> function (“object list comprehension” snippet) for this. We pass this snippet the iterable and a function to perform on each key/value pair.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">ObjectComprehension</span></span>
  use_snippets[<span class="string">'object list comprehension'</span>] = snippets[<span class="string">'object list comprehension'</span>]
  rv = <span class="string">""</span></pre></div></div>
            
        </li>
        
        
        <li id="section-178">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-178">&#182;</a>
              </div>
              <p>We also assign to the <code>property_iterant</code>, <code>value_iterant</code>, or both depending on which one was specified. This supports the syntaxes <code>[k for k of obj]</code>, <code>[k for property k in obj]</code>, <code>[v for value v in obj]</code>, and <code>[k + v for property k with value v in obj]</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> me.property_iterant <span class="keyword">exists</span>
    scope[me.property_iterant.<span class="keyword">value</span>] = <span class="string">'closures ok'</span>
    rv += <span class="string">"<span class="subst">#{me.property_iterant.<span class="keyword">value</span>}</span> = k$p;"</span>
  <span class="keyword">if</span> me.value_iterant <span class="keyword">exists</span>
    scope[me.value_iterant.<span class="keyword">value</span>] = <span class="string">'closures ok'</span>
    rv += <span class="string">"<span class="subst">#{me.value_iterant.<span class="keyword">value</span>}</span> = k$v;"</span>
  rv = <span class="string">"k$compro(<span class="subst">#{me.iterable.js()}</span>,function (k$p,k$v) {<span class="subst">#{rv}</span>; return <span class="subst">#{me.iter_expr.js()}</span>;})"</span>
  <span class="keyword">return</span> rv</pre></div></div>
            
        </li>
        
        
        <li id="section-179">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-179">&#182;</a>
              </div>
              <h3>MapItem</h3>
<p>A <code>MapItem</code> is a single item in an object definition. We pass this straight through to JavaScript. Note that this also covers the subclass <code>ImplicitMapItem</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">MapItem</span></span>
  <span class="keyword">return</span> <span class="string">"<span class="subst">#{me.key.<span class="keyword">value</span>}</span>: <span class="subst">#{me.val.js()}</span>"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-180">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-180">&#182;</a>
              </div>
              <h3>MapExpression</h3>
<p>A <code>MapExpression</code> is an object definition using key/value pairs like <code>{a:1,b:2}</code>. JavaScript supports this syntax, so we just pass it through. Note that this also supports the subclass <code>ImplicitMapExpression</code> which allows multi-line definitions without <code>{}</code>s.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">MapExpression</span></span>
  rv = []
  <span class="keyword">for</span> item <span class="keyword">in</span> me.items
    rv.push item.js()
  rv = rv.join(<span class="string">', '</span>)
  <span class="keyword">return</span> <span class="string">"{<span class="subst">#{rv}</span>}"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-181">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-181">&#182;</a>
              </div>
              <h3>FunctionExpression</h3>
<p><code>FunctionExpression</code>s are function definitions, but like JavaScript they evaluate to a <code>function</code> object. There are several “flavors” of functions that each have their own utility generator function, including constructors, class members, and regular functions/tasks.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">FunctionExpression</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-182">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-182">&#182;</a>
              </div>
              <p>If this is a task (asynchronous), we set the callback to the <code>k$next</code> variable. This will get populated later with the last argument passed into the function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  me.callback = <span class="string">'k$next'</span> <span class="keyword">when</span> me.specifier.<span class="keyword">value</span> <span class="keyword">is</span> <span class="string">'task'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-183">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-183">&#182;</a>
              </div>
              <p>For late binding classes, we pretend to be in the process of defining the owner class by pushing it to the stack. No support for late binding constructors at this time.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> me.name <span class="keyword">exists</span> <span class="keyword">and</span> me.bind_to <span class="keyword">exists</span>
    <span class="keyword">if</span> me.specifier.<span class="keyword">value</span> <span class="keyword">is</span> <span class="string">'method'</span> <span class="keyword">and</span> me.name.<span class="keyword">value</span> <span class="keyword">is</span> <span class="string">'initialize'</span>
      <span class="keyword">throw</span> <span class="keyword">new</span> Error <span class="string">"late binding for constructors is not supported"</span>
    <span class="keyword">else</span>
      push_class()
      class_def = {<span class="attribute">name</span>: me.bind_to.js(), <span class="attribute">code</span>: <span class="string">''</span>, <span class="attribute">args</span>: [], <span class="attribute">has_constructor</span>: <span class="literal">no</span>}
      rv = me.js_class_member()
      pop_class()
      <span class="keyword">return</span> rv</pre></div></div>
            
        </li>
        
        
        <li id="section-184">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-184">&#182;</a>
              </div>
              <p>If this is a member of a class (including a late binding), we run <code>js_constructor</code> if its name is <code>initialize</code>, and <code>js_class_member</code> for normal members. <code>js_constructor</code> will dump this class&#39;s code in the class definition. <code>js_class_member</code> will ensure this function gets added to the class&#39;s prototype.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">else</span> <span class="keyword">if</span> class_defs.length &gt; <span class="number">0</span> <span class="keyword">and</span> me.name <span class="keyword">exists</span> <span class="comment">#is a member function/method</span>
    <span class="keyword">if</span> me.specifier.<span class="keyword">value</span> <span class="keyword">is</span> <span class="string">'method'</span> <span class="keyword">and</span> me.name.<span class="keyword">value</span> <span class="keyword">is</span> <span class="string">'initialize'</span>
      class_def.code += me.js_constructor()
      <span class="keyword">return</span> <span class="string">""</span>
    <span class="keyword">else</span>
      <span class="keyword">return</span> me.js_class_member()</pre></div></div>
            
        </li>
        
        
        <li id="section-185">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-185">&#182;</a>
              </div>
              <p>Normal functions go straight to <code>js_bare_function</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">else</span>
    <span class="keyword">return</span> me.js_bare_<span class="function"><span class="keyword">function</span><span class="params">()</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-186">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-186">&#182;</a>
              </div>
              <p>Bare functions just get the <code>function</code> header and an optional name before generating the body.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js_bare_function</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">FunctionExpression</span></span>
  rv = <span class="string">"function "</span>
  <span class="keyword">if</span> me.name <span class="keyword">exists</span>
    rv += me.name.<span class="keyword">value</span>
  <span class="keyword">return</span> rv + me.js_body()</pre></div></div>
            
        </li>
        
        
        <li id="section-187">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-187">&#182;</a>
              </div>
              <p>Class members get assigned to the class&#39;s prototype if they are methods/tasks. Regular function members are just assigned as a member of the class variable.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js_class_member</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">FunctionExpression</span></span>
  <span class="keyword">if</span> me.specifier.<span class="keyword">value</span> <span class="keyword">is</span> <span class="string">'method'</span> <span class="keyword">or</span> me.specifier.<span class="keyword">value</span> <span class="keyword">is</span> <span class="string">'task'</span>
    rv = <span class="string">"<span class="subst">#{class_def.name}</span>.prototype.<span class="subst">#{me.name.<span class="keyword">value</span>}</span> = function "</span>
  <span class="keyword">else</span>
    rv = <span class="string">"<span class="subst">#{class_def.name}</span>.<span class="subst">#{me.name.<span class="keyword">value</span>}</span> = function "</span>
  <span class="keyword">return</span> rv + me.js_body()</pre></div></div>
            
        </li>
        
        
        <li id="section-188">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-188">&#182;</a>
              </div>
              <p>Constructors are handled a little differently. Since JavaScript “classes” are really just functions, the constructor code has to wind up in a function with the same name as the class. We set the approprate flags for the arguments to the current <code>class_def</code>.</p>
<p>Note: The parameter to <code>js_body</code> appears to be unused?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js_constructor</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">FunctionExpression</span></span>
  class_def.has_constructor = <span class="literal">yes</span>
  rv = <span class="string">"function <span class="subst">#{class_def.name}</span>"</span>
  class_def.args = []
  class_def.arguments = [argument <span class="keyword">for</span> argument <span class="keyword">in</span> me.arguments]
  rv += me.js_body class_def.args
  class_def.arguments.push me.callback <span class="keyword">when</span> me.callback <span class="keyword">exists</span>
  <span class="keyword">return</span> rv</pre></div></div>
            
        </li>
        
        
        <li id="section-189">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-189">&#182;</a>
              </div>
              <p><code>js_body</code> is the worker method that generates the function body.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js_body</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">FunctionExpression</span></span>
  rv = <span class="string">""</span>
  default_arg_js = <span class="string">""</span></pre></div></div>
            
        </li>
        
        
        <li id="section-190">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-190">&#182;</a>
              </div>
              <p>Start a new scope for this function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  push_scope()</pre></div></div>
            
        </li>
        
        
        <li id="section-191">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-191">&#182;</a>
              </div>
              <p>If this is a task (has a callback), define <code>k$next</code> (local only, don&#39;t want this to propagate to lower scopes) and <code>k$this</code> (OK for closures).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> me.callback <span class="keyword">exists</span>
    scope[<span class="string">'k$next'</span>] = <span class="string">'no closures'</span>
    scope[<span class="string">'k$this'</span>] = <span class="string">'closures ok'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-192">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-192">&#182;</a>
              </div>
              <p>We create the argument array here by looking through the argument names.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  arg_names = [argument.name?.<span class="keyword">value</span> <span class="keyword">or</span> argument <span class="keyword">for</span> argument <span class="keyword">in</span> me.arguments]
  <span class="keyword">for</span> arg_name <span class="keyword">in</span> arg_names
    scope[arg_name] = <span class="string">'argument'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-193">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-193">&#182;</a>
              </div>
              <p>Generate the block code. Note: the argument to <code>block.js</code> appears unused?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  block_code = me.block.js(<span class="literal">yes</span>) + me.block.js_closeout()</pre></div></div>
            
        </li>
        
        
        <li id="section-194">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-194">&#182;</a>
              </div>
              <p>We assign default values to arguments if necessary. Normally we just do a <code>null</code> check on arguments to see if they need to be seeded with default values. For tasks, we also need to make sure they aren&#39;t equal to <code>k$next</code> (the callback argument) since it&#39;s always the last argument, even if some are missing.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">for</span> argument <span class="keyword">in</span> me.arguments
    <span class="keyword">if</span> argument.<span class="reserved">default</span> <span class="keyword">exists</span>
      default_arg_js += <span class="string">"if (<span class="subst">#{argument.name.<span class="keyword">value</span>}</span> == null"</span>
      default_arg_js += <span class="string">" || <span class="subst">#{argument.name.<span class="keyword">value</span>}</span> == k$next"</span> <span class="keyword">if</span> me.callback <span class="keyword">exists</span>
      default_arg_js += <span class="string">") <span class="subst">#{argument.name.<span class="keyword">value</span>}</span> = <span class="subst">#{argument.default.js()}</span>;\n"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-195">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-195">&#182;</a>
              </div>
              <p>For async code, we seed <code>k$next</code> with the last argument that is a function using the <code>k$getcb</code> (“get callback”) snippet. We also save <code>this</code> into <code>k$this</code>.</p>
<p>Async functions get wrapped in a <code>try</code> block so that we can catch errors and forward them to our callback.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> me.callback <span class="keyword">exists</span>
    use_snippets[<span class="string">'async'</span>] = snippets[<span class="string">'async'</span>]
    use_snippets[<span class="string">'get callback'</span>] = snippets[<span class="string">'get callback'</span>]
    block_code = <span class="string">"var k$next = k$getcb(arguments);\nk$this = this;\n<span class="subst">#{default_arg_js}</span>try {\n"</span> + indent block_code
  <span class="keyword">else</span>
    block_code = default_arg_js + block_code</pre></div></div>
            
        </li>
        
        
        <li id="section-196">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-196">&#182;</a>
              </div>
              <p>We pop the scope, which generates <code>var</code> definitions as necessary. We pass <code>no</code> for the <code>wrap</code> argument because we do our own function wrapping here.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  rv += indent pop_scope(block_code, <span class="literal">no</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-197">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-197">&#182;</a>
              </div>
              <p>This <code>catch</code> block takes care of any uncaught errors from a task. If an error is caught here, we call back to <code>k$next</code> with the error as the first and only argument. If <code>k$next</code> is another task, this will cause it to throw.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> me.callback <span class="keyword">exists</span>
    rv += <span class="string">"  } catch (k$err) {if (k$next) {return k$async(k$next,k$this,[k$err]);} else {throw k$err;}}\n"</span>
    rv += <span class="string">"  return k$next ? k$async(k$next,k$this) : void 0;\n"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-198">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-198">&#182;</a>
              </div>
              <p>We then prepend the argument code that we generated previously.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  rv = <span class="string">"(<span class="subst">#{arg_names.join(<span class="string">', '</span>)}</span>) {\n<span class="subst">#{rv}</span>}"</span>
  <span class="keyword">return</span> rv</pre></div></div>
            
        </li>
        
        
        <li id="section-199">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-199">&#182;</a>
              </div>
              <h3>FunctionCall</h3>
<p><code>FunctionCall</code> is an accessor that calls a function. We generate JavaScript for each expression in the argument list and just pass it through to JavaScript.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">(as_list)</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">FunctionCall</span></span>
  rv = []
  <span class="keyword">for</span> argument <span class="keyword">in</span> me.arguments
    rv.push argument.js()
  rv.push me.callback_name <span class="keyword">if</span> me.callback_name <span class="keyword">exists</span>
  rv = rv.join <span class="string">', '</span></pre></div></div>
            
        </li>
        
        
        <li id="section-200">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-200">&#182;</a>
              </div>
              <p><code>as_list</code> is currently unused (always false). Note: remove this?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> as_list
    <span class="keyword">return</span> <span class="string">"[<span class="subst">#{rv}</span>]"</span>
  <span class="keyword">else</span>
    <span class="keyword">return</span> <span class="string">"(<span class="subst">#{rv}</span>)"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-201">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-201">&#182;</a>
              </div>
              <p>Function calls can have exisential checks (<code>a?(1)</code>) since they are accessors.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js_existence</span><span class="params">(accessor, undefined_unary, invert)</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">FunctionCall</span></span>
  <span class="keyword">if</span> me.exisential
    <span class="keyword">return</span> check_existence_wrapper(accessor, undefined_unary, invert)
  <span class="keyword">else</span>
    <span class="keyword">return</span> <span class="string">''</span></pre></div></div>
            
        </li>
        
        
        <li id="section-202">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-202">&#182;</a>
              </div>
              <h3>FunctionCallArgument</h3>
<p><code>FunctionCallArgument</code> is a wrapper for an expression in a function call argument list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">FunctionCallArgument</span></span>
  <span class="keyword">return</span> me.val.js()</pre></div></div>
            
        </li>
        
        
        <li id="section-203">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-203">&#182;</a>
              </div>
              <h3>ClassDefinition</h3>
<p>Classes contain a code block with function, method, and task definitions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">ClassDefinition</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-204">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-204">&#182;</a>
              </div>
              <p>For the class definition, we start a new scope and class and populate the <code>class_def</code> global.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  push_scope()
  push_class()
  class_def.name = me.name.<span class="keyword">value</span>
  class_def.parent = me.parent?.<span class="keyword">value</span>
  block_code = me.block.js() + me.block.js_closeout()
  block_code = pop_scope block_code, <span class="literal">no</span>
  rv = <span class="string">'\n'</span> + class_def.code
  rv += <span class="string">'\n'</span> <span class="keyword">if</span> class_def.code? <span class="keyword">isnt</span> <span class="string">''</span></pre></div></div>
            
        </li>
        
        
        <li id="section-205">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-205">&#182;</a>
              </div>
              <p>If there was no <code>initialize</code> method defined, we create a function with the class name. It calls the parent constructor if there is a parent. If the user does define an <code>initialize</code> method, it will generate this for us.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">unless</span> class_def.has_constructor
    rv += <span class="string">"function <span class="subst">#{class_def.name}</span>() {\n"</span>
    <span class="keyword">if</span> me.parent?
      rv += <span class="string">"  return <span class="subst">#{me.parent.<span class="keyword">value</span>}</span>.prototype.constructor.apply(this,arguments);\n"</span>
    rv += <span class="string">"}\n"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-206">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-206">&#182;</a>
              </div>
              <p>Use the inheritance snippet if we have a parent class.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> me.parent?
    rv += <span class="string">"__extends(<span class="subst">#{me.name.<span class="keyword">value</span>}</span>,<span class="subst">#{me.parent.<span class="keyword">value</span>}</span>);\n\n"</span>
    use_snippets[<span class="string">'inherits'</span>] = snippets[<span class="string">'inherits'</span>]
  <span class="keyword">else</span>
    rv += <span class="string">'\n'</span>
  rv += block_code
  pop_class()
  <span class="keyword">return</span> rv</pre></div></div>
            
        </li>
        
        
        <li id="section-207">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-207">&#182;</a>
              </div>
              <h3>TryCatch</h3>
<p><code>TryCatch</code> blocks are context dependent. In synchronous contexts, they are very similar to JavaScript equivalents. In asynchronous contexts, things get very complicated because we need to redefine the error handling code every time we generate a new callback. As a result, we keep a <code>try_block_stack</code> so that we can regenerate error handlers whenever we make a new scope.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">TryCatch</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-208">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-208">&#182;</a>
              </div>
              <p>Add this object to the stack and pass conditional and loop status down the tree.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  try_block_stack.unshift <span class="literal">me</span>
  me.try_block.in_conditional = <span class="literal">yes</span>
  me.try_block.in_loop = me.in_loop
  me.original_callback = me.callback <span class="keyword">unless</span> me.original_callback <span class="keyword">exists</span></pre></div></div>
            
        </li>
        
        
        <li id="section-209">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-209">&#182;</a>
              </div>
              <p>Try making synchronous code.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  rv = me.js_no_callbacks()</pre></div></div>
            
        </li>
        
        
        <li id="section-210">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-210">&#182;</a>
              </div>
              <p>If that failed, we fall back to asynchronous code generation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> me.callback <span class="keyword">isnt</span> current_callback
    me.callback = create_callback()
    me.closeout_callback = me.callback
    rv = me.js_callbacks()</pre></div></div>
            
        </li>
        
        
        <li id="section-211">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-211">&#182;</a>
              </div>
              <p>For synchronous code, we don&#39;t need to keep this object on the stack since it is closed out.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">else</span>
    try_block_stack.shift()
  <span class="keyword">return</span> rv</pre></div></div>
            
        </li>
        
        
        <li id="section-212">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-212">&#182;</a>
              </div>
              <p>For synchronous code, we use the wrapper methods to generate code. We need to set <code>original_callback</code> to our original callback (whatever the current callback is) since we don&#39;t have a callback of our own.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js_no_callbacks</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">TryCatch</span></span>
  rv = me.js_wrapper_try()
  me.try_block.original_callback = me.original_callback
  rv += multi_indent(me.try_block.js() + me.try_block.js_closeout(), try_block_stack.length)
  rv += me.js_wrapper_catch()
  <span class="keyword">return</span> rv</pre></div></div>
            
        </li>
        
        
        <li id="section-213">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-213">&#182;</a>
              </div>
              <p>For asynchronous code, we still use the wrappers but start a new closeout callback that all branches need to eventually call. We pass this up to the parent block so it knows what callback it is inserting code into.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js_callbacks</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">TryCatch</span></span>
  rv = me.js_wrapper_try()
  me.try_block.original_callback = me.callback
  rv += multi_indent(me.try_block.js() + me.try_block.js_closeout(), try_block_stack.length)
  rv += me.js_wrapper_catch()
  rv += <span class="string">"function <span class="subst">#{me.callback}</span>() {\n"</span>
  try_block_stack.shift()
  rv += indent render_try_blocks()
  me.parent_block.closeout_callback = me.original_callback
  <span class="keyword">return</span> rv<span class="function">

<span class="keyword">method</span> <span class="title">js_wrapper_try</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">TryCatch</span></span>
  rv = <span class="string">"try {\n"</span>
  <span class="keyword">return</span> rv</pre></div></div>
            
        </li>
        
        
        <li id="section-214">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-214">&#182;</a>
              </div>
              <p><code>js_wrapper_catch</code> generates catch blocks and associated code. It is meant to be called multiple times (once each time the <code>try</code>/<code>catch</code> stack is regenerated for a callback).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js_wrapper_catch</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">TryCatch</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-215">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-215">&#182;</a>
              </div>
              <p>This is a bit of a hack until we support catch callbacks. We mark <code>in_catch</code> on the top try block so that the <code>WaitForStatement</code> will fail to generate here. <code>wait for</code>s in catch blocks are not yet supported.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  try_block_stack[<span class="number">0</span>].in_catch = <span class="literal">yes</span> <span class="keyword">when</span> try_block_stack[<span class="number">0</span>] <span class="keyword">exists</span></pre></div></div>
            
        </li>
        
        
        <li id="section-216">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-216">&#182;</a>
              </div>
              <p>Close the <code>try</code> block.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  rv = <span class="string">"}"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-217">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-217">&#182;</a>
              </div>
              <p>If the user actually specified a <code>catch</code> block (remember they are optional in Kal), generate the code for that block. The identifier name is optional in Kal but not JavaScript, so we just use <code>k$e</code> to throw the value away if it&#39;s unneeded.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> me.catch_block <span class="keyword">exists</span>
    rv += <span class="string">" catch (<span class="subst">#{me.identifier?.<span class="keyword">value</span> <span class="keyword">or</span> <span class="string">'k$e'</span>}</span>) {\n"</span>
    rv += indent(me.catch_block.js() + me.catch_block.js_closeout())</pre></div></div>
            
        </li>
        
        
        <li id="section-218">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-218">&#182;</a>
              </div>
              <p>If no <code>catch</code> block was specified, we just make a blank one.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">else</span>
    rv += <span class="string">" catch (k$e) {"</span>
    rv += <span class="string">'\n'</span> <span class="keyword">if</span> parfor_cb <span class="keyword">exists</span> <span class="keyword">or</span> me.closeout_callback <span class="keyword">exists</span></pre></div></div>
            
        </li>
        
        
        <li id="section-219">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-219">&#182;</a>
              </div>
              <p>Parallel <code>for</code> loops require that we call back to the <code>parfor_cb</code>, otherwise the loop will never finish.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> parfor_cb <span class="keyword">exists</span>
    use_snippets[<span class="string">'async'</span>] = snippets[<span class="string">'async'</span>]
    rv += indent <span class="string">"return k$async(<span class="subst">#{parfor_cb}</span>,<span class="subst">#{kthis()}</span>);\n"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-220">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-220">&#182;</a>
              </div>
              <p>Once complete, we need to call back to the closeout callback.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">else</span> <span class="keyword">if</span> me.closeout_callback <span class="keyword">exists</span>
    use_snippets[<span class="string">'async'</span>] = snippets[<span class="string">'async'</span>]
    rv += indent <span class="string">"return k$async(<span class="subst">#{me.closeout_callback}</span>,<span class="subst">#{kthis()}</span>);\n"</span>
  rv += <span class="string">'}\n'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-221">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-221">&#182;</a>
              </div>
              <p>Unhack to avoid <code>wait for</code>s in <code>catch</code> blocks.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  try_block_stack[<span class="number">0</span>].in_catch = <span class="literal">no</span> <span class="keyword">when</span> try_block_stack[<span class="number">0</span>] <span class="keyword">exists</span>
  <span class="keyword">return</span> rv</pre></div></div>
            
        </li>
        
        
        <li id="section-222">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-222">&#182;</a>
              </div>
              <h3>SuperStatement</h3>
<p>The <code>SuperStatement</code> calls the parent class&#39;s constructor on the current object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">SuperStatement</span></span>
  <span class="keyword">return</span> <span class="string">""</span> <span class="keyword">when</span> class_def.parent <span class="keyword">doesnt</span> <span class="keyword">exist</span>
  rv = <span class="string">"<span class="subst">#{class_def.parent}</span>.prototype.constructor.apply(<span class="subst">#{kthis()}</span>,"</span>
  <span class="keyword">if</span> me.accessor <span class="keyword">exists</span>
    rv += me.accessor.js(<span class="literal">yes</span>)
  <span class="keyword">else</span>
    rv += <span class="string">"arguments"</span>
  rv += <span class="string">");\n"</span>
  <span class="keyword">return</span> rv</pre></div></div>
            
        </li>
        
        
        <li id="section-223">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-223">&#182;</a>
              </div>
              <h3>WaitForStatement</h3>
<p><code>WaitForStatement</code>s generate new callbacks. They are always considered asynchronous code. This generator needs to be robust to being called multiple times since many parent objects will attempt to make synchronous code, then try again if they see a <code>wait for</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">WaitForStatement</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-224">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-224">&#182;</a>
              </div>
              <p><code>wait for</code>s are not currently supported in <code>catch</code> blocks.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">throw</span> <span class="keyword">new</span> Error <span class="string">"wait fors not supported in catch blocks"</span> <span class="keyword">when</span> try_block_stack[<span class="number">0</span>]?.in_catch</pre></div></div>
            
        </li>
        
        
        <li id="section-225">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-225">&#182;</a>
              </div>
              <p>If this is a “bare” file, we can&#39;t use the <code>return</code> statement at the top level when executing callbacks.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  prefix = <span class="string">""</span> <span class="keyword">if</span> me.parent_block.bare <span class="keyword">otherwise</span> <span class="string">"return "</span></pre></div></div>
            
        </li>
        
        
        <li id="section-226">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-226">&#182;</a>
              </div>
              <p>Make the new callback identifier. Most parents that care about context check for the side effect of this function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  me.new_callback = create_callback()</pre></div></div>
            
        </li>
        
        
        <li id="section-227">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-227">&#182;</a>
              </div>
              <p>Standard <code>wait for</code>s have an r-value. <code>pause for</code>s (a subclass of this) do not have an r-value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> me.rvalue <span class="keyword">exists</span></pre></div></div>
            
        </li>
        
        
        <li id="section-228">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-228">&#182;</a>
              </div>
              <p>For <code>wait for</code>s, we set the <code>callback_args</code> to the l-values on the left side of the <code>wait for</code>. We do support multiple return values here. The <code>callback_name</code> field tells this <code>FunctionCall</code> which callback function to pass in as its last argument. This allows the <code>FunctionCall</code> generator method to generate a call to the task with an extra callback argument. Note: <code>me.rvalue.callback_args</code> appears to be unused?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    me.rvalue.callback_args = me.lvalue
    me.rvalue.accessors[me.rvalue.accessors.length - <span class="number">1</span>].callback_name = me.new_callback
    rv = <span class="string">"<span class="subst">#{prefix}</span><span class="subst">#{me.rvalue.js()}</span>;\n"</span>
  <span class="keyword">else</span></pre></div></div>
            
        </li>
        
        
        <li id="section-229">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-229">&#182;</a>
              </div>
              <p>In <code>pause for</code>s, we use constant folding since we multiply the time value by 1000 if possible. Because it looks better.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    number = me.tvalue.number_constant()
    <span class="keyword">if</span> number <span class="keyword">exists</span>
      tvalue_js = <span class="string">"<span class="subst">#{number * <span class="number">1000</span>}</span>"</span>
    <span class="keyword">else</span>
      tvalue_js = me.tvalue.js()
      tvalue_js = <span class="string">"(<span class="subst">#{me.tvalue.js()}</span>)*1000"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-230">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-230">&#182;</a>
              </div>
              <p>Then we call <code>setTimeout</code> with our callback as the argument.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rv = <span class="string">"<span class="subst">#{prefix}</span>setTimeout(<span class="subst">#{me.new_callback}</span>,<span class="subst">#{tvalue_js}</span>);\n"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-231">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-231">&#182;</a>
              </div>
              <p>If there is a tail conditional, we wrap the call in the conditional. Note: TODO - I think we need to pass that code on the second line to <code>conditional.js</code> as the false expression.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> me.conditional <span class="keyword">exists</span>
    rv = me.conditional.js(rv, <span class="literal">no</span>)
    rv += <span class="string">"<span class="subst">#{prefix}</span><span class="subst">#{me.new_callback}</span>();\n"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-232">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-232">&#182;</a>
              </div>
              <p>Next we compile our “block” which is actually a <code>BlockWithoutIndent</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  rv_block = <span class="string">""</span></pre></div></div>
            
        </li>
        
        
        <li id="section-233">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-233">&#182;</a>
              </div>
              <p>We assign return values (arguments to the callback) to their appropriate variable names and declare the variables. If this is a <code>safe</code> wait for (<code>no_errors</code>), we don‘t need to add an error argument. This is used for “non-standard” functions like node’s <code>http.get</code> which don&#39;t call back with error arguments.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  arg_i = <span class="number">0</span> <span class="keyword">when</span> me.no_errors <span class="keyword">otherwise</span> <span class="number">1</span>
  <span class="keyword">for</span> argument <span class="keyword">in</span> me.lvalue?.arguments <span class="keyword">or</span> []
    rv_block += <span class="string">"<span class="subst">#{argument.base.<span class="keyword">value</span>}</span> = arguments[<span class="subst">#{arg_i}</span>];\n"</span>
    scope[argument.base.<span class="keyword">value</span>] = <span class="string">'closures ok'</span> <span class="keyword">unless</span> scope[argument.base.<span class="keyword">value</span>] <span class="keyword">exists</span>
    arg_i += <span class="number">1</span></pre></div></div>
            
        </li>
        
        
        <li id="section-234">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-234">&#182;</a>
              </div>
              <p>Pass down the conditional and loop states.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  me.block.in_conditional = me.in_conditional
  me.block.in_loop = me.in_loop</pre></div></div>
            
        </li>
        
        
        <li id="section-235">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-235">&#182;</a>
              </div>
              <p>Now compile the block and wrap it in the callback <code>function</code> wrapper.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  rv_block += me.block.js()
  rv += <span class="string">"function <span class="subst">#{me.new_callback}</span>() {\n"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-236">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-236">&#182;</a>
              </div>
              <p><code>try_count</code> is used to determine the indentation level. Note: TODO - it looks like the second line here does nothing <code>try_block</code> is not used anywhere.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  try_count = try_block_stack.length + <span class="number">1</span>
  try_count += <span class="number">1</span> <span class="keyword">if</span> try_block <span class="keyword">exists</span></pre></div></div>
            
        </li>
        
        
        <li id="section-237">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-237">&#182;</a>
              </div>
              <p>We render any currently used <code>try</code> blocks in the new function scope.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  rv += indent render_try_blocks()</pre></div></div>
            
        </li>
        
        
        <li id="section-238">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-238">&#182;</a>
              </div>
              <p>The first thing we do is throw any errors passed into the callback so the user can catch them with normal <code>try</code> blocks.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  rv += multi_indent(<span class="string">"if (arguments[0] != null) throw arguments[0];\n"</span>, try_count) <span class="keyword">except</span> <span class="keyword">when</span> me.no_errors</pre></div></div>
            
        </li>
        
        
        <li id="section-239">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-239">&#182;</a>
              </div>
              <p>Add the block code.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  rv += multi_indent rv_block, try_count</pre></div></div>
            
        </li>
        
        
        <li id="section-240">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-240">&#182;</a>
              </div>
              <p>At the end of the block, call back to any required closeouts or implied returns.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> me.in_conditional <span class="keyword">or</span> me.in_loop
    use_snippets[<span class="string">'async'</span>] = snippets[<span class="string">'async'</span>]
    rv += multi_indent <span class="string">"<span class="subst">#{prefix}</span>k$async(<span class="subst">#{me.parent_block.original_callback}</span>,<span class="subst">#{kthis()}</span>);\n"</span>, me.block.indent_level + try_count
  <span class="keyword">else</span> <span class="keyword">if</span> scope[<span class="string">'k$next'</span>]
    use_snippets[<span class="string">'async'</span>] = snippets[<span class="string">'async'</span>]
    rv += multi_indent <span class="string">"<span class="subst">#{prefix}</span>k$next ? k$async(k$next,<span class="subst">#{kthis()}</span>) : void 0;\n"</span>, me.block.indent_level + try_count</pre></div></div>
            
        </li>
        
        
        <li id="section-241">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-241">&#182;</a>
              </div>
              <p>Close out the function, generating <code>catch</code> blocks from the stack.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  rv += me.block.js_closeout()
  <span class="keyword">return</span> rv</pre></div></div>
            
        </li>
        
        
        <li id="section-242">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-242">&#182;</a>
              </div>
              <h3>WaitForExpression</h3>
<p>A <code>WaitForExpression</code> is like a <code>WaitForStatement</code> except that it only occurs inside a <code>RunInParallelBlock</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">WaitForExpression</span></span>
  rv_block = <span class="string">""</span></pre></div></div>
            
        </li>
        
        
        <li id="section-243">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-243">&#182;</a>
              </div>
              <p>Make a new callback.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  me.new_callback = create_callback()</pre></div></div>
            
        </li>
        
        
        <li id="section-244">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-244">&#182;</a>
              </div>
              <p>If this is a <code>safe wait for</code>, we don‘t need an error argument in the callback. This is used for “non-standard” functions like node’s <code>http.get</code> which don&#39;t call back with error arguments. This section generates code that assigns return values (arguments to our callback) to variables. We add these variables to the local scope.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  arg_i = <span class="number">0</span> <span class="keyword">when</span> me.no_errors <span class="keyword">otherwise</span> <span class="number">1</span>
  <span class="keyword">for</span> argument <span class="keyword">in</span> me.lvalue?.arguments <span class="keyword">or</span> []
    rv_block += <span class="string">"<span class="subst">#{argument.base.<span class="keyword">value</span>}</span> = arguments[<span class="subst">#{arg_i}</span>];\n"</span>
    scope[argument.base.<span class="keyword">value</span>] = <span class="string">'closures ok'</span> <span class="keyword">unless</span> scope[argument.base.<span class="keyword">value</span>] <span class="keyword">exists</span>
    arg_i += <span class="number">1</span></pre></div></div>
            
        </li>
        
        
        <li id="section-245">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-245">&#182;</a>
              </div>
              <p>Note: TODO - I think this does nothing.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  me.rvalue.callback_args = me.lvalue</pre></div></div>
            
        </li>
        
        
        <li id="section-246">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-246">&#182;</a>
              </div>
              <p>We tell the r-value function call accessor to use our callback as the last argument.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  me.rvalue.accessors[me.rvalue.accessors.length - <span class="number">1</span>].callback_name = me.new_callback</pre></div></div>
            
        </li>
        
        
        <li id="section-247">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-247">&#182;</a>
              </div>
              <p>We add the function call code and any conditional wrapping as appropriate.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  rv = <span class="string">"<span class="subst">#{me.rvalue.js()}</span>;\n"</span>
  <span class="keyword">if</span> me.conditional <span class="keyword">exists</span>
    rv = me.conditional.js(rv, <span class="literal">no</span>, <span class="string">"k$async(<span class="subst">#{me.callback}</span>,<span class="subst">#{kthis()}</span>);\n"</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-248">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-248">&#182;</a>
              </div>
              <p><code>WaitForExpression</code>s store any errors in the <code>error_holder</code> array, which is thrown if more than zero errors occur (see the <code>RunInParallelBlock</code>, which sets these properties). <code>safe wait for</code>s don&#39;t check for errors.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  rv += <span class="string">"function <span class="subst">#{me.new_callback}</span>() {\n"</span>
  use_snippets[<span class="string">'async'</span>] = snippets[<span class="string">'async'</span>]
  <span class="keyword">unless</span> me.no_errors
    rv += <span class="string">"  if (arguments[0] != null) {\n"</span>
    rv += <span class="string">"    <span class="subst">#{me.error_holder}</span>[<span class="subst">#{me.error_index}</span>] = arguments[0];\n"</span>
    rv += <span class="string">"    return k$async(<span class="subst">#{me.callback}</span>,<span class="subst">#{kthis()}</span>);\n"</span>
    rv += <span class="string">"  }\n"</span>
  rv += indent rv_block
  rv += <span class="string">"  k$async(<span class="subst">#{me.callback}</span>,<span class="subst">#{kthis()}</span>);\n"</span>
  rv += <span class="string">"}\n"</span>
  <span class="keyword">return</span> rv</pre></div></div>
            
        </li>
        
        
        <li id="section-249">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-249">&#182;</a>
              </div>
              <h3>RunInParallelBlock</h3>
<p>A <code>RunInParallelBlock</code> kicks off several <code>WaitForExpression</code>s in parallel. It calls its own callback when all these tasks are done. It throws an error (with an array of errors from each <code>wait for</code>) if there were any errors.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">method</span> <span class="title">js</span><span class="params">()</span> <span class="keyword">of</span> <span class="title">Grammar</span>.<span class="title">RunInParallelBlock</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-250">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-250">&#182;</a>
              </div>
              <p>Make our callback and a loop counter and loop error variable.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  me.callback = create_callback()
  loop_counter = <span class="string">"klc$<span class="subst">#{for_count}</span>"</span>
  loop_errors = <span class="string">"kle$<span class="subst">#{for_count}</span>"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-251">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-251">&#182;</a>
              </div>
              <p>This is treated much like a parallel <code>for</code> loop.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  for_count += <span class="number">1</span></pre></div></div>
            
        </li>
        
        
        <li id="section-252">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-252">&#182;</a>
              </div>
              <p>Make sure the counters and error array are defined in the local scope.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  scope[loop_counter] = <span class="string">'no closures'</span>
  scope[loop_errors] = <span class="string">'no closures'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-253">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-253">&#182;</a>
              </div>
              <p>Set the counter variable to the number of tasks. Set the errors array to empty.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  rv = <span class="string">"<span class="subst">#{loop_counter}</span> = <span class="subst">#{me.wait_fors.length}</span>;\n<span class="subst">#{loop_errors}</span> = [];\n"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-254">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-254">&#182;</a>
              </div>
              <p>Set the flags on each child <code>WaitForExpression</code>. We give each expression an index to store its error information to.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  wf_index = <span class="number">0</span>
  <span class="keyword">for</span> wait_for <span class="keyword">in</span> me.wait_fors
    wait_for.callback = me.callback
    wait_for.parent_block = me.parent_block
    wait_for.error_holder = loop_errors
    wait_for.error_index = wf_index
    rv += <span class="string">"<span class="subst">#{wait_for.js()}</span>"</span>
    wf_index += <span class="number">1</span></pre></div></div>
            
        </li>
        
        
        <li id="section-255">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-255">&#182;</a>
              </div>
              <p>Our callback checks if all tasks are done. If they are not, it just returns.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  rv += <span class="string">"function <span class="subst">#{me.callback}</span>() {\n"</span>
  rv += <span class="string">"  if (--<span class="subst">#{loop_counter}</span>) return;\n"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-256">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-256">&#182;</a>
              </div>
              <p>Add in the user&#39;s <code>try</code> blocks.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  rv += indent render_try_blocks()</pre></div></div>
            
        </li>
        
        
        <li id="section-257">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-257">&#182;</a>
              </div>
              <p>If we are done, check for errors in the array and throw if there were any.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  rv += multi_indent <span class="string">"  for (var <span class="subst">#{loop_errors}</span>i = 0; <span class="subst">#{loop_errors}</span>i &lt; <span class="subst">#{wf_index}</span>; <span class="subst">#{loop_errors}</span>i++) { if (<span class="subst">#{loop_errors}</span>[<span class="subst">#{loop_errors}</span>i]) throw <span class="subst">#{loop_errors}</span>; }\n"</span>, try_block_stack.length
  me.parent_block.closeout_callback = me.original_callback
  <span class="keyword">return</span> rv</pre></div></div>
            
        </li>
        
        
        <li id="section-258">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-258">&#182;</a>
              </div>
              <h1>Snippets</h1>

            </div>
            
        </li>
        
        
        <li id="section-259">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-259">&#182;</a>
              </div>
              <p>These are useful blocks of code that are only included in the output when used.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>snippets =</pre></div></div>
            
        </li>
        
        
        <li id="section-260">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-260">&#182;</a>
              </div>
              <p><code>in</code> checks if a variable is a member of an array. It is used by the <code>in</code> operator.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="string">'in'</span>: <span class="string">'var k$indexof = [].indexOf || function (item) { for (var i = 0, l = this.length; i &lt; l; i++) { if (i in this &amp;&amp; this[i] === item) return i; } return -1; };'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-261">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-261">&#182;</a>
              </div>
              <p><code>inherits</code> creates the <code>__extends</code> function which makes class inheritance work by copying members to a child class&#39;s prototype.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="string">'inherits'</span>: <span class="string">'var __hasProp = {}.hasOwnProperty, __extends = function (child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-262">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-262">&#182;</a>
              </div>
              <p><code>array list comprehension</code> preforms a function on each element of an iterable, returning an array of return values. This is used to execute list comprehensions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="string">'array list comprehension'</span>: <span class="string">'var k$comprl = function (iterable,func) {var o = []; if (iterable instanceof Array || typeof iterable.length == "number") {for (var i=0;i&lt;iterable.length;i++) {o.push(func(iterable[i]));}} else if (typeof iterable.next == "function") {var i; while ((i = iterable.next()) != null) {o.push(func(i));}} else {throw "Object is not iterable";}return o;};'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-263">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-263">&#182;</a>
              </div>
              <p><code>object list comprehension</code> preforms a function on each key-value pair of an object, returning an array of return values. This is used to execute object comprehensions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="string">'object list comprehension'</span>: <span class="string">'var k$compro = function (obj,func) {var o = []; for (var k in obj) {o.push(func(k,obj[k]));}return o;}'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-264">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-264">&#182;</a>
              </div>
              <p><code>async</code> calls a function on the next execution cycle using <code>process.nextTick</code> (if available) or <code>setTimeout</code>. This is used for callbacks from tasks.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="string">'async'</span>: <span class="string">'var k$async = (typeof process === "undefined" || !(process.nextTick)) ? (function (fn,self,args) {setTimeout(function () {fn.apply(self,args);}, 0);}) : (function (fn,self,args) {process.nextTick(function () {fn.apply(self,args);});});'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-265">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-265">&#182;</a>
              </div>
              <p><code>get callback</code> is a helper function that gets the last function argument passed to the current function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="string">'get callback'</span>: <span class="string">'var k$getcb = function (args) {return typeof args[args.length-1] == "function" ? args[args.length-1] : function () {}};'</span></pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
